
Memory_interface_app.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c4  00800060  00001d62  00001df6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e5  00800124  00800124  00001eba  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001eba  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001eec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000508  00000000  00000000  00001f28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000470d  00000000  00000000  00002430  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c47  00000000  00000000  00006b3d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002684  00000000  00000000  00008784  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000948  00000000  00000000  0000ae08  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001726  00000000  00000000  0000b750  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021e0  00000000  00000000  0000ce76  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003d0  00000000  00000000  0000f056  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
       4:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
       8:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
       c:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      10:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      14:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      18:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      1c:	0c 94 88 0a 	jmp	0x1510	; 0x1510 <__vector_7>
      20:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      24:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      28:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      2c:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      30:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      34:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      38:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      3c:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      40:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      44:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__vector_17>
      48:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      4c:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      50:	0c 94 52 00 	jmp	0xa4	; 0xa4 <__bad_interrupt>
      54:	fc 07       	cpc	r31, r28
      56:	2d 08       	sbc	r2, r13
      58:	03 08       	sbc	r0, r3
      5a:	00 09       	sbc	r16, r0
      5c:	0c 09       	sbc	r16, r12
      5e:	a2 08       	sbc	r10, r2
      60:	4c 08       	sbc	r4, r12
      62:	df 08       	sbc	r13, r15
      64:	8a 08       	sbc	r8, r10
      66:	22 08       	sbc	r2, r2
      68:	f7 08       	sbc	r15, r7

0000006a <__ctors_end>:
      6a:	11 24       	eor	r1, r1
      6c:	1f be       	out	0x3f, r1	; 63
      6e:	cf e5       	ldi	r28, 0x5F	; 95
      70:	d8 e0       	ldi	r29, 0x08	; 8
      72:	de bf       	out	0x3e, r29	; 62
      74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a0 e6       	ldi	r26, 0x60	; 96
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	e2 e6       	ldi	r30, 0x62	; 98
      7e:	fd e1       	ldi	r31, 0x1D	; 29
      80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
      82:	05 90       	lpm	r0, Z+
      84:	0d 92       	st	X+, r0
      86:	a4 32       	cpi	r26, 0x24	; 36
      88:	b1 07       	cpc	r27, r17
      8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
      8c:	24 e0       	ldi	r18, 0x04	; 4
      8e:	a4 e2       	ldi	r26, 0x24	; 36
      90:	b1 e0       	ldi	r27, 0x01	; 1
      92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
      94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
      96:	a9 30       	cpi	r26, 0x09	; 9
      98:	b2 07       	cpc	r27, r18
      9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>
      9c:	0e 94 0e 06 	call	0xc1c	; 0xc1c <main>
      a0:	0c 94 af 0e 	jmp	0x1d5e	; 0x1d5e <_exit>

000000a4 <__bad_interrupt>:
      a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a8 <App1_init>:
static unsigned char State;
static unsigned char DateWriteFlag;
static unsigned char DataReadFlag;
void App1_init(void)
{
	State = STATE_IDLE;
      a8:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <State>
	DateWriteFlag = (unsigned char)0;
      ac:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <DateWriteFlag>
	DataReadFlag = (unsigned char)0;
      b0:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <DataReadFlag>
      b4:	08 95       	ret

000000b6 <App1_WriteCbk>:
}
void App1_WriteCbk(void)
{
	DateWriteFlag = (unsigned char)1;
      b6:	81 e0       	ldi	r24, 0x01	; 1
      b8:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <DateWriteFlag>
      bc:	08 95       	ret

000000be <App1_ReadCbk>:
}
void App1_ReadCbk(void)
{
	DataReadFlag = (unsigned char)1;
      be:	81 e0       	ldi	r24, 0x01	; 1
      c0:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <DataReadFlag>
      c4:	08 95       	ret

000000c6 <App1_main>:
}
void App1_main(void)
{
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	00 d0       	rcall	.+0      	; 0xcc <App1_main+0x6>
      cc:	00 d0       	rcall	.+0      	; 0xce <App1_main+0x8>
      ce:	cd b7       	in	r28, 0x3d	; 61
      d0:	de b7       	in	r29, 0x3e	; 62
	static unsigned char CounterData;
	switch(State)
      d2:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <State>
      d6:	81 30       	cpi	r24, 0x01	; 1
      d8:	a9 f0       	breq	.+42     	; 0x104 <App1_main+0x3e>
      da:	18 f0       	brcs	.+6      	; 0xe2 <App1_main+0x1c>
      dc:	82 30       	cpi	r24, 0x02	; 2
      de:	e9 f1       	breq	.+122    	; 0x15a <App1_main+0x94>
      e0:	44 c0       	rjmp	.+136    	; 0x16a <App1_main+0xa4>
	{
		case STATE_IDLE:
		{
			BtnStateType BtnState;
			BTN_GetState(&BtnState,BTN1_ID);
      e2:	60 e0       	ldi	r22, 0x00	; 0
      e4:	ce 01       	movw	r24, r28
      e6:	01 96       	adiw	r24, 0x01	; 1
      e8:	0e 94 2d 01 	call	0x25a	; 0x25a <BTN_GetState>
			if(BtnState == PRESSED)
      ec:	89 81       	ldd	r24, Y+1	; 0x01
      ee:	81 30       	cpi	r24, 0x01	; 1
      f0:	e1 f5       	brne	.+120    	; 0x16a <App1_main+0xa4>
			{
				NVM_ReadBlock(COUNTER1_BLOCK_ID,&CounterData);
      f2:	64 e2       	ldi	r22, 0x24	; 36
      f4:	71 e0       	ldi	r23, 0x01	; 1
      f6:	80 e0       	ldi	r24, 0x00	; 0
      f8:	0e 94 bb 07 	call	0xf76	; 0xf76 <NVM_ReadBlock>
				State = STATE_READING;
      fc:	81 e0       	ldi	r24, 0x01	; 1
      fe:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <State>
			else
			{
				
			}
		}
		break;
     102:	33 c0       	rjmp	.+102    	; 0x16a <App1_main+0xa4>
		case STATE_READING:
		{
			if(DataReadFlag == 1)
     104:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <DataReadFlag>
     108:	81 30       	cpi	r24, 0x01	; 1
     10a:	79 f5       	brne	.+94     	; 0x16a <App1_main+0xa4>
			{
				char str[4];
				DataReadFlag = 0;
     10c:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <DataReadFlag>
				CounterData ++;
     110:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <__data_end>
     114:	8f 5f       	subi	r24, 0xFF	; 255
     116:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__data_end>
				lcd_clrScreen();
     11a:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
				lcd_gotoxy(0,0);
     11e:	60 e0       	ldi	r22, 0x00	; 0
     120:	80 e0       	ldi	r24, 0x00	; 0
     122:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				lcd_gotoxy(0,0);
     126:	60 e0       	ldi	r22, 0x00	; 0
     128:	80 e0       	ldi	r24, 0x00	; 0
     12a:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     12e:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <__data_end>
     132:	4a e0       	ldi	r20, 0x0A	; 10
     134:	be 01       	movw	r22, r28
     136:	6f 5f       	subi	r22, 0xFF	; 255
     138:	7f 4f       	sbci	r23, 0xFF	; 255
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <__itoa_ncheck>
				itoa(CounterData,str,10);
				lcd_dispString(str);	
     140:	ce 01       	movw	r24, r28
     142:	01 96       	adiw	r24, 0x01	; 1
     144:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				NVM_WriteBlock(COUNTER1_BLOCK_ID,&CounterData);
     148:	64 e2       	ldi	r22, 0x24	; 36
     14a:	71 e0       	ldi	r23, 0x01	; 1
     14c:	80 e0       	ldi	r24, 0x00	; 0
     14e:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <NVM_WriteBlock>
				State = STATE_WRITING;				
     152:	82 e0       	ldi	r24, 0x02	; 2
     154:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <State>
     158:	08 c0       	rjmp	.+16     	; 0x16a <App1_main+0xa4>
			}
		}
		break;
		case STATE_WRITING:
		{
			if(DateWriteFlag == 1)
     15a:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <DateWriteFlag>
     15e:	81 30       	cpi	r24, 0x01	; 1
     160:	21 f4       	brne	.+8      	; 0x16a <App1_main+0xa4>
			{
				DateWriteFlag = 0;
     162:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <DateWriteFlag>
				State = STATE_IDLE;
     166:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <State>
			}
		}
		break;
	}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	0f 90       	pop	r0
     170:	0f 90       	pop	r0
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <App2_init>:
static unsigned char State;
static unsigned char DateWriteFlag;
static unsigned char DataReadFlag;
void App2_init(void)
{
	State = STATE_IDLE;
     178:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <State>
	DateWriteFlag = (unsigned char)0;
     17c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <DateWriteFlag>
	DataReadFlag = (unsigned char)0;
     180:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <DataReadFlag>
     184:	08 95       	ret

00000186 <App2_WriteCbk>:
}
void App2_WriteCbk(void)
{
	DateWriteFlag = (unsigned char)1;
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <DateWriteFlag>
     18c:	08 95       	ret

0000018e <App2_ReadCbk>:
}
void App2_ReadCbk(void)
{
	DataReadFlag = 1;
     18e:	81 e0       	ldi	r24, 0x01	; 1
     190:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <DataReadFlag>
     194:	08 95       	ret

00000196 <App2_main>:

}
void App2_main(void)
{
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <App2_main+0x6>
     19c:	00 d0       	rcall	.+0      	; 0x19e <App2_main+0x8>
     19e:	cd b7       	in	r28, 0x3d	; 61
     1a0:	de b7       	in	r29, 0x3e	; 62
	static unsigned char CounterData;
	switch(State)
     1a2:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <State>
     1a6:	81 30       	cpi	r24, 0x01	; 1
     1a8:	b1 f0       	breq	.+44     	; 0x1d6 <App2_main+0x40>
     1aa:	20 f0       	brcs	.+8      	; 0x1b4 <App2_main+0x1e>
     1ac:	82 30       	cpi	r24, 0x02	; 2
     1ae:	09 f4       	brne	.+2      	; 0x1b2 <App2_main+0x1c>
     1b0:	3f c0       	rjmp	.+126    	; 0x230 <App2_main+0x9a>
     1b2:	46 c0       	rjmp	.+140    	; 0x240 <App2_main+0xaa>
	{
		case STATE_IDLE:
		{
			BtnStateType BtnState;
			BTN_GetState(&BtnState,BTN2_ID);
     1b4:	61 e0       	ldi	r22, 0x01	; 1
     1b6:	ce 01       	movw	r24, r28
     1b8:	01 96       	adiw	r24, 0x01	; 1
     1ba:	0e 94 2d 01 	call	0x25a	; 0x25a <BTN_GetState>
			if(BtnState == PRESSED)
     1be:	89 81       	ldd	r24, Y+1	; 0x01
     1c0:	81 30       	cpi	r24, 0x01	; 1
     1c2:	f1 f5       	brne	.+124    	; 0x240 <App2_main+0xaa>
			{
				
				TCNT2=NVM_ReadBlock(COUNTER1_BLOCK_ID,&CounterData);
     1c4:	68 e2       	ldi	r22, 0x28	; 40
     1c6:	71 e0       	ldi	r23, 0x01	; 1
     1c8:	0e 94 bb 07 	call	0xf76	; 0xf76 <NVM_ReadBlock>
     1cc:	84 bd       	out	0x24, r24	; 36
				State = STATE_READING;
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <State>
			else
			{
				
			}
		}
		break;
     1d4:	35 c0       	rjmp	.+106    	; 0x240 <App2_main+0xaa>
		case STATE_READING:
		{
			if(DataReadFlag == 1)
     1d6:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <DataReadFlag>
     1da:	81 30       	cpi	r24, 0x01	; 1
     1dc:	89 f5       	brne	.+98     	; 0x240 <App2_main+0xaa>
			{
				TCNT2=0x10;
     1de:	80 e1       	ldi	r24, 0x10	; 16
     1e0:	84 bd       	out	0x24, r24	; 36
				char str[4];
				DataReadFlag = 0;
     1e2:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <DataReadFlag>
				CounterData ++;
     1e6:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <CounterData.1902>
     1ea:	8f 5f       	subi	r24, 0xFF	; 255
     1ec:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <CounterData.1902>
				lcd_gotoxy(0,1);
     1f0:	61 e0       	ldi	r22, 0x01	; 1
     1f2:	80 e0       	ldi	r24, 0x00	; 0
     1f4:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				lcd_clrScreen();
     1f8:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
				lcd_gotoxy(0,1);
     1fc:	61 e0       	ldi	r22, 0x01	; 1
     1fe:	80 e0       	ldi	r24, 0x00	; 0
     200:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
     204:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <CounterData.1902>
     208:	4a e0       	ldi	r20, 0x0A	; 10
     20a:	be 01       	movw	r22, r28
     20c:	6f 5f       	subi	r22, 0xFF	; 255
     20e:	7f 4f       	sbci	r23, 0xFF	; 255
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <__itoa_ncheck>
				itoa(CounterData,str,10);
				lcd_dispString(str);	
     216:	ce 01       	movw	r24, r28
     218:	01 96       	adiw	r24, 0x01	; 1
     21a:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				NVM_WriteBlock(COUNTER1_BLOCK_ID,&CounterData);
     21e:	68 e2       	ldi	r22, 0x28	; 40
     220:	71 e0       	ldi	r23, 0x01	; 1
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <NVM_WriteBlock>
				State = STATE_WRITING;				
     228:	82 e0       	ldi	r24, 0x02	; 2
     22a:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <State>
     22e:	08 c0       	rjmp	.+16     	; 0x240 <App2_main+0xaa>
			}
		}
		break;
		case STATE_WRITING:
		{
			if(DateWriteFlag == 1)
     230:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <DateWriteFlag>
     234:	81 30       	cpi	r24, 0x01	; 1
     236:	21 f4       	brne	.+8      	; 0x240 <App2_main+0xaa>
			{
				DateWriteFlag = 0;
     238:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <DateWriteFlag>
				State = STATE_IDLE;
     23c:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <State>
			}
		}
		break;
	}
     240:	0f 90       	pop	r0
     242:	0f 90       	pop	r0
     244:	0f 90       	pop	r0
     246:	0f 90       	pop	r0
     248:	df 91       	pop	r29
     24a:	cf 91       	pop	r28
     24c:	08 95       	ret

0000024e <BTN_Init>:
{
	/***Initializing first state for all buttons****/
	unsigned char i=0;
	for(i=0;i<BTN_NUM_OF_BUTTONS ;i++)
	{
		Array_state[i] = BUT_OFF;
     24e:	ef e2       	ldi	r30, 0x2F	; 47
     250:	f1 e0       	ldi	r31, 0x01	; 1
     252:	10 82       	st	Z, r1
     254:	11 82       	std	Z+1, r1	; 0x01
     256:	12 82       	std	Z+2, r1	; 0x02
     258:	08 95       	ret

0000025a <BTN_GetState>:
		
	}
}
void BTN_GetState(BtnStateType *BtnStatePtr, unsigned char BtnId)
{
	*BtnStatePtr = Array_state[BtnId];
     25a:	e6 2f       	mov	r30, r22
     25c:	f0 e0       	ldi	r31, 0x00	; 0
     25e:	e1 5d       	subi	r30, 0xD1	; 209
     260:	fe 4f       	sbci	r31, 0xFE	; 254
     262:	20 81       	ld	r18, Z
     264:	fc 01       	movw	r30, r24
     266:	20 83       	st	Z, r18
     268:	08 95       	ret

0000026a <BTN_Manager>:
{

	static uint8_t au8_btn1state=0;
	static uint8_t au8_btn2state=0;
	static uint8_t au8_btn3state=0;
	if((PINB&0x01)==0)
     26a:	b0 99       	sbic	0x16, 0	; 22
     26c:	0e c0       	rjmp	.+28     	; 0x28a <BTN_Manager+0x20>
	{
		au8_btn1state++;
     26e:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <au8_btn1state.1665>
     272:	8f 5f       	subi	r24, 0xFF	; 255
		if(au8_btn1state==3)
     274:	83 30       	cpi	r24, 0x03	; 3
     276:	19 f0       	breq	.+6      	; 0x27e <BTN_Manager+0x14>
	static uint8_t au8_btn1state=0;
	static uint8_t au8_btn2state=0;
	static uint8_t au8_btn3state=0;
	if((PINB&0x01)==0)
	{
		au8_btn1state++;
     278:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <au8_btn1state.1665>
     27c:	0a c0       	rjmp	.+20     	; 0x292 <BTN_Manager+0x28>
		if(au8_btn1state==3)
		{
			au8_btn1state=0;
     27e:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <au8_btn1state.1665>
			Array_state[0]=1;
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <Array_state>
     288:	04 c0       	rjmp	.+8      	; 0x292 <BTN_Manager+0x28>
		}
	}
	else	
	{
		au8_btn1state=0;
     28a:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <au8_btn1state.1665>
		Array_state[0]=0;
     28e:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <Array_state>
	}
	if((PINB&0x02)==0)
     292:	b1 99       	sbic	0x16, 1	; 22
     294:	0e c0       	rjmp	.+28     	; 0x2b2 <BTN_Manager+0x48>
	{
		au8_btn2state++;
     296:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <au8_btn2state.1666>
     29a:	8f 5f       	subi	r24, 0xFF	; 255
		if(au8_btn2state==3)
     29c:	83 30       	cpi	r24, 0x03	; 3
     29e:	19 f0       	breq	.+6      	; 0x2a6 <BTN_Manager+0x3c>
		au8_btn1state=0;
		Array_state[0]=0;
	}
	if((PINB&0x02)==0)
	{
		au8_btn2state++;
     2a0:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <au8_btn2state.1666>
     2a4:	0a c0       	rjmp	.+20     	; 0x2ba <BTN_Manager+0x50>
		if(au8_btn2state==3)
		{
			au8_btn2state=0;
     2a6:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <au8_btn2state.1666>
			Array_state[1]=1;
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <Array_state+0x1>
     2b0:	04 c0       	rjmp	.+8      	; 0x2ba <BTN_Manager+0x50>
		}
	}
	else
	{
		au8_btn2state=0;
     2b2:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <au8_btn2state.1666>
		Array_state[1]=0;
     2b6:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <Array_state+0x1>
	}
	if((PINB&0x04)==0)
     2ba:	b2 99       	sbic	0x16, 2	; 22
     2bc:	0e c0       	rjmp	.+28     	; 0x2da <BTN_Manager+0x70>
	{
		au8_btn3state++;
     2be:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <au8_btn3state.1667>
     2c2:	8f 5f       	subi	r24, 0xFF	; 255
		if(au8_btn3state==3)
     2c4:	83 30       	cpi	r24, 0x03	; 3
     2c6:	19 f0       	breq	.+6      	; 0x2ce <BTN_Manager+0x64>
		au8_btn2state=0;
		Array_state[1]=0;
	}
	if((PINB&0x04)==0)
	{
		au8_btn3state++;
     2c8:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <au8_btn3state.1667>
     2cc:	08 95       	ret
		if(au8_btn3state==3)
		{
			au8_btn3state=0;
     2ce:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <au8_btn3state.1667>
			Array_state[2]=1;
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <Array_state+0x2>
     2d8:	08 95       	ret
		}
	}
	else
	{
		au8_btn3state=0;
     2da:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <au8_btn3state.1667>
		Array_state[2]=0;
     2de:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <Array_state+0x2>
     2e2:	08 95       	ret

000002e4 <DIO_Init>:
#define PIN_REG(PORT_ID) *((volatile unsigned char*)(LUT[PORT_ID] - PIN_REG_OFFSET))
#define DDR_REG(PORT_ID) *((volatile unsigned char*)(LUT[PORT_ID] - DDR_REG_OFFSET))  
#define PORT_REG(PORT_ID) *((volatile unsigned char*)(LUT[PORT_ID] - PORT_REG_OFFSET))

void DIO_Init(void)
{
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
     2e8:	ab e7       	ldi	r26, 0x7B	; 123
     2ea:	b0 e0       	ldi	r27, 0x00	; 0
     2ec:	2b ea       	ldi	r18, 0xAB	; 171
     2ee:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char loop;
	for(loop = 0; loop < DIO_NUM_OF_GROUPS; loop++)
	{
		DDR_REG(DIO_ConfigParam[loop].Port) &= ~(DIO_ConfigParam[loop].Mask);
     2f0:	11 96       	adiw	r26, 0x01	; 1
     2f2:	ec 91       	ld	r30, X
     2f4:	11 97       	sbiw	r26, 0x01	; 1
     2f6:	f0 e0       	ldi	r31, 0x00	; 0
     2f8:	e9 58       	subi	r30, 0x89	; 137
     2fa:	ff 4f       	sbci	r31, 0xFF	; 255
     2fc:	e0 81       	ld	r30, Z
     2fe:	f0 e0       	ldi	r31, 0x00	; 0
     300:	ef 01       	movw	r28, r30
     302:	9a 91       	ld	r25, -Y
     304:	4c 91       	ld	r20, X
     306:	84 2f       	mov	r24, r20
     308:	80 95       	com	r24
     30a:	98 23       	and	r25, r24
     30c:	98 83       	st	Y, r25
		DDR_REG(DIO_ConfigParam[loop].Port) |= (DIO_ConfigParam[loop].Mask & DIO_ConfigParam[loop].Direction);
     30e:	58 81       	ld	r21, Y
     310:	12 96       	adiw	r26, 0x02	; 2
     312:	9c 91       	ld	r25, X
     314:	12 97       	sbiw	r26, 0x02	; 2
     316:	94 23       	and	r25, r20
     318:	95 2b       	or	r25, r21
     31a:	98 83       	st	Y, r25
		PORT_REG(DIO_ConfigParam[loop].Port) &= ~(DIO_ConfigParam[loop].Mask);
     31c:	90 81       	ld	r25, Z
     31e:	89 23       	and	r24, r25
     320:	80 83       	st	Z, r24
		PORT_REG(DIO_ConfigParam[loop].Port) |= (DIO_ConfigParam[loop].Mask & DIO_ConfigParam[loop].UsePullUp);
     322:	90 81       	ld	r25, Z
     324:	13 96       	adiw	r26, 0x03	; 3
     326:	8c 91       	ld	r24, X
     328:	13 97       	sbiw	r26, 0x03	; 3
     32a:	84 23       	and	r24, r20
     32c:	89 2b       	or	r24, r25
     32e:	80 83       	st	Z, r24
     330:	14 96       	adiw	r26, 0x04	; 4
#define PORT_REG(PORT_ID) *((volatile unsigned char*)(LUT[PORT_ID] - PORT_REG_OFFSET))

void DIO_Init(void)
{
	unsigned char loop;
	for(loop = 0; loop < DIO_NUM_OF_GROUPS; loop++)
     332:	a2 17       	cp	r26, r18
     334:	b3 07       	cpc	r27, r19
     336:	e1 f6       	brne	.-72     	; 0x2f0 <DIO_Init+0xc>
		DDR_REG(DIO_ConfigParam[loop].Port) &= ~(DIO_ConfigParam[loop].Mask);
		DDR_REG(DIO_ConfigParam[loop].Port) |= (DIO_ConfigParam[loop].Mask & DIO_ConfigParam[loop].Direction);
		PORT_REG(DIO_ConfigParam[loop].Port) &= ~(DIO_ConfigParam[loop].Mask);
		PORT_REG(DIO_ConfigParam[loop].Port) |= (DIO_ConfigParam[loop].Mask & DIO_ConfigParam[loop].UsePullUp);
	}
}
     338:	df 91       	pop	r29
     33a:	cf 91       	pop	r28
     33c:	08 95       	ret

0000033e <DIO_Write>:
void DIO_Write(unsigned char GroupId, unsigned char Data)
{
	unsigned char TempData;
	TempData = PORT_REG(DIO_ConfigParam[GroupId].Port);
     33e:	24 e0       	ldi	r18, 0x04	; 4
     340:	82 9f       	mul	r24, r18
     342:	c0 01       	movw	r24, r0
     344:	11 24       	eor	r1, r1
     346:	dc 01       	movw	r26, r24
     348:	a5 58       	subi	r26, 0x85	; 133
     34a:	bf 4f       	sbci	r27, 0xFF	; 255
     34c:	11 96       	adiw	r26, 0x01	; 1
     34e:	ec 91       	ld	r30, X
     350:	11 97       	sbiw	r26, 0x01	; 1
     352:	f0 e0       	ldi	r31, 0x00	; 0
     354:	e9 58       	subi	r30, 0x89	; 137
     356:	ff 4f       	sbci	r31, 0xFF	; 255
     358:	e0 81       	ld	r30, Z
     35a:	f0 e0       	ldi	r31, 0x00	; 0
     35c:	90 81       	ld	r25, Z
	TempData &= ~(DIO_ConfigParam[GroupId].Mask);
     35e:	2c 91       	ld	r18, X
     360:	82 2f       	mov	r24, r18
     362:	80 95       	com	r24
     364:	89 23       	and	r24, r25
	TempData |= (DIO_ConfigParam[GroupId].Mask & Data);
     366:	62 23       	and	r22, r18
     368:	68 2b       	or	r22, r24
	PORT_REG(DIO_ConfigParam[GroupId].Port) = TempData;
     36a:	60 83       	st	Z, r22
     36c:	08 95       	ret

0000036e <EEEXT_Init>:
{
    #if (ENABLE == TEST)
    printf("Function: EEEXT_Init start \n");
    #endif
    /*initiate globla variables*/
    gu8_PhyAddress = PHY_ADDRESS_INITAIAL_VALUE; /*value out of scope to generate error*/
     36e:	88 ec       	ldi	r24, 0xC8	; 200
     370:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <gu8_PhyAddress>
    gu8_Length = LENGTH_INITIAL_VALUE; /*value out of scope to generate error*/
     374:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <gu8_Length>
    gu8ptr_DataPtr = NULL; /*null pointer*/
     378:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <gu8ptr_DataPtr+0x1>
     37c:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <gu8ptr_DataPtr>

    gu8_OperationFlag = OPERATION_FLAG_CLEAR;
     380:	88 e0       	ldi	r24, 0x08	; 8
     382:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <gu8_OperationFlag>
    gu8_WaitFlag = WAIT_FLAG_CLEAR;
     386:	86 e1       	ldi	r24, 0x16	; 22
     388:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <gu8_WaitFlag>
     38c:	08 95       	ret

0000038e <EEEXT_ReqWrite>:
    printf("Function: EEEXT_Init finished \n");
    #endif
}

EEEXT_CheckType EEEXT_ReqWrite(unsigned char StartAddress, const unsigned char* DataPtr, unsigned char Length)
{
     38e:	98 2f       	mov	r25, r24
    au8_TotalDatasize = StartAddress * Length;
    #if (ENABLE == TEST)
    printf("Total Data Size is %d \n", au8_TotalDatasize);
    #endif
    /*make sure that total data size fit with external EEPROM size*/
    if (EEEXT_MAX_SIZE < au8_TotalDatasize)
     390:	84 9f       	mul	r24, r20
     392:	80 2d       	mov	r24, r0
     394:	11 24       	eor	r1, r1
     396:	81 38       	cpi	r24, 0x81	; 129
     398:	b8 f4       	brcc	.+46     	; 0x3c8 <EEEXT_ReqWrite+0x3a>
EEEXT_CheckType EEEXT_ReqWrite(unsigned char StartAddress, const unsigned char* DataPtr, unsigned char Length)
{
    #if (ENABLE == TEST)
    printf("Function: EEEXT_ReqWrite start \n");
    #endif
    EEEXT_CheckType FuncReturn = EEEXT_OK; /*consider the return ok as initial value*/ 
     39a:	81 e0       	ldi	r24, 0x01	; 1
     39c:	61 15       	cp	r22, r1
     39e:	71 05       	cpc	r23, r1
     3a0:	09 f0       	breq	.+2      	; 0x3a4 <EEEXT_ReqWrite+0x16>
     3a2:	80 e0       	ldi	r24, 0x00	; 0
        printf("Invalid Data Size \n");
        #endif
    }
    
    /*if the parameter is valid*/
    if (EEEXT_OK == FuncReturn)
     3a4:	81 11       	cpse	r24, r1
     3a6:	13 c0       	rjmp	.+38     	; 0x3ce <EEEXT_ReqWrite+0x40>
    {
        #if (ENABLE == TEST)
        printf("Valid Data Size \n");
        #endif
        /*ensure that the module is available*/
        if (OPERATION_FLAG_CLEAR == gu8_OperationFlag)
     3a8:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <gu8_OperationFlag>
     3ac:	28 30       	cpi	r18, 0x08	; 8
     3ae:	71 f4       	brne	.+28     	; 0x3cc <EEEXT_ReqWrite+0x3e>
        {
            #if (ENABLE == TEST)
            printf("Function: EEEXT_ReqWrite storing parameters ... \n");
            #endif
            /*stores the parameter in global variable to use it in main function*/
            gu8_Length = Length;
     3b0:	40 93 36 01 	sts	0x0136, r20	; 0x800136 <gu8_Length>
            gu8_PhyAddress = StartAddress;
     3b4:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <gu8_PhyAddress>
            gu8ptr_DataPtr = DataPtr;
     3b8:	70 93 35 01 	sts	0x0135, r23	; 0x800135 <gu8ptr_DataPtr+0x1>
     3bc:	60 93 34 01 	sts	0x0134, r22	; 0x800134 <gu8ptr_DataPtr>
            /*stores required operation*/
            gu8_OperationFlag = OPERATION_FLAG_WRITE;
     3c0:	97 e0       	ldi	r25, 0x07	; 7
     3c2:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <gu8_OperationFlag>
     3c6:	08 95       	ret
    printf("Total Data Size is %d \n", au8_TotalDatasize);
    #endif
    /*make sure that total data size fit with external EEPROM size*/
    if (EEEXT_MAX_SIZE < au8_TotalDatasize)
    {
        FuncReturn = EEEXT_NOK;
     3c8:	81 e0       	ldi	r24, 0x01	; 1
     3ca:	08 95       	ret
            gu8_OperationFlag = OPERATION_FLAG_WRITE;
        } 
        /*if the module unavailable*/
        else
        {
            FuncReturn = EEEXT_BUSY;
     3cc:	82 e0       	ldi	r24, 0x02	; 2
    }
    #if (ENABLE == TEST)
    printf("Function: EEEXT_ReqWrite finished \n");
    #endif
    return FuncReturn;
}
     3ce:	08 95       	ret

000003d0 <EEEXT_ReqRead>:


EEEXT_CheckType EEEXT_ReqRead(unsigned char StartAddress,const unsigned char* DataPtr,unsigned char Length)
{
     3d0:	98 2f       	mov	r25, r24
    #if (ENABLE == TEST)
    printf("Total Data Size is %d \n", au8_TotalDatasize);
    #endif
    
    /*make sure that total data size fit with external EEPROM size*/
    if (EEEXT_MAX_SIZE < au8_TotalDatasize)
     3d2:	84 9f       	mul	r24, r20
     3d4:	80 2d       	mov	r24, r0
     3d6:	11 24       	eor	r1, r1
     3d8:	81 38       	cpi	r24, 0x81	; 129
     3da:	b8 f4       	brcc	.+46     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
EEEXT_CheckType EEEXT_ReqRead(unsigned char StartAddress,const unsigned char* DataPtr,unsigned char Length)
{
    #if (ENABLE == TEST)
    printf("Function: EEEXT_ReqRead start \n");
    #endif
    EEEXT_CheckType FuncReturn = EEEXT_OK; /*consider the return ok as initial value*/
     3dc:	81 e0       	ldi	r24, 0x01	; 1
     3de:	61 15       	cp	r22, r1
     3e0:	71 05       	cpc	r23, r1
     3e2:	09 f0       	breq	.+2      	; 0x3e6 <EEEXT_ReqRead+0x16>
     3e4:	80 e0       	ldi	r24, 0x00	; 0
        printf("Invalid Data Size \n");
        #endif
    }
    
    /*check if the parameter is valid*/
    if (EEEXT_OK == FuncReturn)
     3e6:	81 11       	cpse	r24, r1
     3e8:	13 c0       	rjmp	.+38     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
    {
        #if (ENABLE == TEST)
        printf("Valid Data Size \n");
        #endif
        /*ensure that the module is available*/
       if (OPERATION_FLAG_CLEAR == gu8_OperationFlag)
     3ea:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <gu8_OperationFlag>
     3ee:	28 30       	cpi	r18, 0x08	; 8
     3f0:	71 f4       	brne	.+28     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
       {
           #if (ENABLE == TEST)
           printf("Function: EEEXT_ReqRead storing parameters ... \n");
           #endif
           /*stores the parameter in global variable to use it in main function*/
           gu8_Length = Length;
     3f2:	40 93 36 01 	sts	0x0136, r20	; 0x800136 <gu8_Length>
           gu8_PhyAddress = StartAddress;
     3f6:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <gu8_PhyAddress>
           gu8ptr_DataPtr = DataPtr;
     3fa:	70 93 35 01 	sts	0x0135, r23	; 0x800135 <gu8ptr_DataPtr+0x1>
     3fe:	60 93 34 01 	sts	0x0134, r22	; 0x800134 <gu8ptr_DataPtr>
           /*stores required operation*/
           gu8_OperationFlag = OPERATION_FLAG_READ;
     402:	96 e0       	ldi	r25, 0x06	; 6
     404:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <gu8_OperationFlag>
     408:	08 95       	ret
    #endif
    
    /*make sure that total data size fit with external EEPROM size*/
    if (EEEXT_MAX_SIZE < au8_TotalDatasize)
    {
        FuncReturn = EEEXT_NOK;
     40a:	81 e0       	ldi	r24, 0x01	; 1
     40c:	08 95       	ret
           gu8_OperationFlag = OPERATION_FLAG_READ;
       } 
       /*if the module unavailable*/
       else
       {
           FuncReturn = EEEXT_BUSY;
     40e:	82 e0       	ldi	r24, 0x02	; 2
    }
    #if (ENABLE == TEST)
    printf("Function: EEEXT_ReqRead finished \n");
    #endif
    return FuncReturn;
}
     410:	08 95       	ret

00000412 <EEEXT_Main>:
    printf("Function: EEEXT_Main start \n");
    #endif
    I2C_CheckType I2C_Return = I2C_OK; /*consider the return of called function is ok as initial value*/
    static uint8_t gu8_MainFuncStatus = IDLE_STATUS; /*begain the function from idle state*/
    
    switch(gu8_MainFuncStatus)
     412:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     416:	8c 30       	cpi	r24, 0x0C	; 12
     418:	09 f4       	brne	.+2      	; 0x41c <EEEXT_Main+0xa>
     41a:	53 c0       	rjmp	.+166    	; 0x4c2 <EEEXT_Main+0xb0>
     41c:	28 f4       	brcc	.+10     	; 0x428 <EEEXT_Main+0x16>
     41e:	8a 30       	cpi	r24, 0x0A	; 10
     420:	51 f0       	breq	.+20     	; 0x436 <EEEXT_Main+0x24>
     422:	8b 30       	cpi	r24, 0x0B	; 11
     424:	d9 f1       	breq	.+118    	; 0x49c <EEEXT_Main+0x8a>
     426:	08 95       	ret
     428:	8e 30       	cpi	r24, 0x0E	; 14
     42a:	89 f0       	breq	.+34     	; 0x44e <EEEXT_Main+0x3c>
     42c:	08 f4       	brcc	.+2      	; 0x430 <EEEXT_Main+0x1e>
     42e:	5c c0       	rjmp	.+184    	; 0x4e8 <EEEXT_Main+0xd6>
     430:	8f 30       	cpi	r24, 0x0F	; 15
     432:	e9 f0       	breq	.+58     	; 0x46e <EEEXT_Main+0x5c>
     434:	08 95       	ret
        case IDLE_STATUS:
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main in IDLE Status \n");
        #endif
        /*check if there is a required operation or not*/
        if (OPERATION_FLAG_CLEAR != gu8_OperationFlag)
     436:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <gu8_OperationFlag>
     43a:	88 30       	cpi	r24, 0x08	; 8
     43c:	21 f0       	breq	.+8      	; 0x446 <EEEXT_Main+0x34>
        {
            gu8_MainFuncStatus = CONFG_STATUS; /*if there is operation move the state to config*/
     43e:	8e e0       	ldi	r24, 0x0E	; 14
     440:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     444:	08 95       	ret
        }  
        else
        {
            gu8_MainFuncStatus = IDLE_STATUS;
     446:	8a e0       	ldi	r24, 0x0A	; 10
     448:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     44c:	08 95       	ret
        #endif
        /*Configure the EEPROM by sending the required address to read from or write to*/
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main write start address in EEPROM ... \n");
        #endif
        I2C_Return = I2C_ReqWrite(EXTERNAL_EEPROM_ADDRESS, &gu8_PhyAddress, PHY_ADDRESS_LENGTH);
     44e:	41 e0       	ldi	r20, 0x01	; 1
     450:	67 e3       	ldi	r22, 0x37	; 55
     452:	71 e0       	ldi	r23, 0x01	; 1
     454:	80 ea       	ldi	r24, 0xA0	; 160
     456:	0e 94 00 04 	call	0x800	; 0x800 <I2C_ReqWrite>
        if (I2C_OK == I2C_Return)
     45a:	81 11       	cpse	r24, r1
     45c:	04 c0       	rjmp	.+8      	; 0x466 <EEEXT_Main+0x54>
        {
            gu8_MainFuncStatus = WAIT_CONFIG_STATUS; /*move the status if the call occurs correctly*/
     45e:	8f e0       	ldi	r24, 0x0F	; 15
     460:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     464:	08 95       	ret
            printf("Start address write function executed and Status change to WAIT CONFIG \n");
            #endif
        }
        else
        {
            gu8_MainFuncStatus = CONFG_STATUS;
     466:	8e e0       	ldi	r24, 0x0E	; 14
     468:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     46c:	08 95       	ret
        case WAIT_CONFIG_STATUS:
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main in WAIT CONFG Status \n");
        #endif
        /*wait until EEPROM configure correctly*/
        if (WAIT_FLAG_CONFG == gu8_WaitFlag)
     46e:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <gu8_WaitFlag>
     472:	84 31       	cpi	r24, 0x14	; 20
     474:	79 f4       	brne	.+30     	; 0x494 <EEEXT_Main+0x82>
        {
            #if (ENABLE == TEST)
            printf("Start Address Write operation Finished \n");
            #endif
            /*move the status according to the desired operation (R/W)*/
            if (OPERATION_FLAG_READ == gu8_OperationFlag)
     476:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <gu8_OperationFlag>
     47a:	86 30       	cpi	r24, 0x06	; 6
     47c:	21 f4       	brne	.+8      	; 0x486 <EEEXT_Main+0x74>
            {
                gu8_MainFuncStatus = READ_STATUS;
     47e:	8b e0       	ldi	r24, 0x0B	; 11
     480:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     484:	08 95       	ret
                #if (ENABLE == TEST)
                printf("Function: EEEXT_Main status change to READ Status \n");
                #endif 
            } 
            else if (OPERATION_FLAG_WRITE == gu8_OperationFlag)
     486:	87 30       	cpi	r24, 0x07	; 7
     488:	09 f0       	breq	.+2      	; 0x48c <EEEXT_Main+0x7a>
     48a:	50 c0       	rjmp	.+160    	; 0x52c <EEEXT_Main+0x11a>
            {
                gu8_MainFuncStatus = WRITE_STATUS;
     48c:	8c e0       	ldi	r24, 0x0C	; 12
     48e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     492:	08 95       	ret
                #endif
            }                
        } 
        else
        {
            gu8_MainFuncStatus = WAIT_CONFIG_STATUS;
     494:	8f e0       	ldi	r24, 0x0F	; 15
     496:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     49a:	08 95       	ret
        #endif
        /*read data from external EEPROM through I2C*/
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main Reading from I2C ... \n");
        #endif
        I2C_Return = I2C_ReqRead(EXTERNAL_EEPROM_ADDRESS, gu8ptr_DataPtr, gu8_Length);
     49c:	60 91 34 01 	lds	r22, 0x0134	; 0x800134 <gu8ptr_DataPtr>
     4a0:	70 91 35 01 	lds	r23, 0x0135	; 0x800135 <gu8ptr_DataPtr+0x1>
     4a4:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <gu8_Length>
     4a8:	80 ea       	ldi	r24, 0xA0	; 160
     4aa:	0e 94 22 04 	call	0x844	; 0x844 <I2C_ReqRead>
        if (I2C_OK == I2C_Return)
     4ae:	81 11       	cpse	r24, r1
     4b0:	04 c0       	rjmp	.+8      	; 0x4ba <EEEXT_Main+0xa8>
        {
            gu8_MainFuncStatus = WAIT_OPERATION_STATUS; /*move the status if the read occurred*/
     4b2:	8d e0       	ldi	r24, 0x0D	; 13
     4b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     4b8:	08 95       	ret
            printf("Function: EEEXT_Main change status to WAIT OPERATION Status \n");
            #endif
        }
        else
        {
            gu8_MainFuncStatus = READ_STATUS;
     4ba:	8b e0       	ldi	r24, 0x0B	; 11
     4bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     4c0:	08 95       	ret
        #endif
        /*write data from external EEPROM through I2C*/
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main Writing through I2C ... \n");
        #endif
        I2C_Return = I2C_ReqWrite(EXTERNAL_EEPROM_ADDRESS, gu8ptr_DataPtr, gu8_Length);
     4c2:	60 91 34 01 	lds	r22, 0x0134	; 0x800134 <gu8ptr_DataPtr>
     4c6:	70 91 35 01 	lds	r23, 0x0135	; 0x800135 <gu8ptr_DataPtr+0x1>
     4ca:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <gu8_Length>
     4ce:	80 ea       	ldi	r24, 0xA0	; 160
     4d0:	0e 94 00 04 	call	0x800	; 0x800 <I2C_ReqWrite>
        if (I2C_OK == I2C_Return)
     4d4:	81 11       	cpse	r24, r1
     4d6:	04 c0       	rjmp	.+8      	; 0x4e0 <EEEXT_Main+0xce>
        {
            gu8_MainFuncStatus = WAIT_OPERATION_STATUS; /*move the status if the write occurred*/
     4d8:	8d e0       	ldi	r24, 0x0D	; 13
     4da:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     4de:	08 95       	ret
            printf("Function: EEEXT_Main change status to WAIT OPERATION Status \n");
            #endif
        }
        else
        {
            gu8_MainFuncStatus = WRITE_STATUS;
     4e0:	8c e0       	ldi	r24, 0x0C	; 12
     4e2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     4e6:	08 95       	ret
        case WAIT_OPERATION_STATUS:
        #if (ENABLE == TEST)
        printf("Function: EEEXT_Main in WAIT OPERATION Status \n");
        #endif
        /*wait until the operation complete*/
        if (WAIT_FLAG_OPERATION == gu8_WaitFlag)
     4e8:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <gu8_WaitFlag>
     4ec:	85 31       	cpi	r24, 0x15	; 21
     4ee:	d9 f4       	brne	.+54     	; 0x526 <EEEXT_Main+0x114>
            printf("Desired Operation Finished \n");
            printf("Reset Flags \n");
            #endif
            
            /*configure the variables to new operation*/
            gu8_MainFuncStatus = IDLE_STATUS;
     4f0:	8a e0       	ldi	r24, 0x0A	; 10
     4f2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
            gu8_WaitFlag = WAIT_FLAG_CLEAR;
     4f6:	86 e1       	ldi	r24, 0x16	; 22
     4f8:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <gu8_WaitFlag>
            /*notify the memory interface that operation is done*/
            if (OPERATION_FLAG_READ == gu8_OperationFlag)
     4fc:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <gu8_OperationFlag>
     500:	86 30       	cpi	r24, 0x06	; 6
     502:	31 f4       	brne	.+12     	; 0x510 <EEEXT_Main+0xfe>
            {
                #if (ENABLE == TEST)
                printf("Call ReadDoneCbkPtr function \n");
                #endif
                EEXT_ConfigParam.ReadDoneCbkPtr();
     504:	e0 91 ad 00 	lds	r30, 0x00AD	; 0x8000ad <EEXT_ConfigParam+0x2>
     508:	f0 91 ae 00 	lds	r31, 0x00AE	; 0x8000ae <EEXT_ConfigParam+0x3>
     50c:	09 95       	icall
     50e:	07 c0       	rjmp	.+14     	; 0x51e <EEEXT_Main+0x10c>
            } 
            else if (OPERATION_FLAG_WRITE == gu8_OperationFlag)
     510:	87 30       	cpi	r24, 0x07	; 7
     512:	29 f4       	brne	.+10     	; 0x51e <EEEXT_Main+0x10c>
            {
                #if (ENABLE == TEST)
                printf("Call WriteDoneCbkPtr function \n");
                #endif
                EEXT_ConfigParam.WriteDoneCbkPtr();
     514:	e0 91 ab 00 	lds	r30, 0x00AB	; 0x8000ab <EEXT_ConfigParam>
     518:	f0 91 ac 00 	lds	r31, 0x00AC	; 0x8000ac <EEXT_ConfigParam+0x1>
     51c:	09 95       	icall
                #if (ENABLE == TEST)
                printf("Operation Flag Value invalid \n");
                #endif
                
            }
            gu8_OperationFlag = OPERATION_FLAG_CLEAR;
     51e:	88 e0       	ldi	r24, 0x08	; 8
     520:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <gu8_OperationFlag>
     524:	08 95       	ret
        } 
        else
        {
            gu8_MainFuncStatus = WAIT_OPERATION_STATUS;
     526:	8d e0       	ldi	r24, 0x0D	; 13
     528:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     52c:	08 95       	ret

0000052e <EEXT_ACtionDoneCallback>:
void EEXT_ACtionDoneCallback(void)
{
    #if (ENABLE == TEST)
    printf("Function: EEXT_ACtionDoneCallback start \n");
    #endif
    if (WAIT_FLAG_CLEAR == gu8_WaitFlag)
     52e:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <gu8_WaitFlag>
     532:	86 31       	cpi	r24, 0x16	; 22
     534:	21 f4       	brne	.+8      	; 0x53e <EEXT_ACtionDoneCallback+0x10>
    {
        /*change the flag status when EEPROM confg complete*/
        gu8_WaitFlag = WAIT_FLAG_CONFG;
     536:	84 e1       	ldi	r24, 0x14	; 20
     538:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <gu8_WaitFlag>
     53c:	08 95       	ret
        #if (ENABLE == TEST)
        printf("Wait Flag changed to CONFIG \n");
        #endif
    }
    else if (WAIT_FLAG_CONFG == gu8_WaitFlag)
     53e:	84 31       	cpi	r24, 0x14	; 20
     540:	19 f4       	brne	.+6      	; 0x548 <EEXT_ACtionDoneCallback+0x1a>
    {
        /*change the flag status when the operation complete*/
        gu8_WaitFlag = WAIT_FLAG_OPERATION;
     542:	85 e1       	ldi	r24, 0x15	; 21
     544:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <gu8_WaitFlag>
     548:	08 95       	ret

0000054a <EEINT_Init>:
static unsigned char gu8_Length;

void EEINT_Init(void)
{
	/*set interrupt*/ 
	EECR|=(1<<EERIE);
     54a:	e3 9a       	sbi	0x1c, 3	; 28
	/*raise init_flag*/
	gu8_initfalg=INITIALIZED;
     54c:	81 e0       	ldi	r24, 0x01	; 1
     54e:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <gu8_initfalg>
     552:	08 95       	ret

00000554 <EEINT_ReqWrite>:

EEINT_CheckType EEINT_ReqWrite(unsigned char StartAddress,unsigned char* DataPtr,unsigned char Length)
{
EEINT_CheckType au8_errorstate=EEINT_OK;
	/*CHECK FOR  VOID POINTER AND MOODULE INITIALIZED*/
	if((DataPtr==NULL)||(gu8_initfalg==UN_INITIALIZED))
     554:	61 15       	cp	r22, r1
     556:	71 05       	cpc	r23, r1
     558:	b9 f0       	breq	.+46     	; 0x588 <EEINT_ReqWrite+0x34>
     55a:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <gu8_initfalg>
     55e:	99 23       	and	r25, r25
     560:	a9 f0       	breq	.+42     	; 0x58c <EEINT_ReqWrite+0x38>
			au8_errorstate=EEINT_NOK;
		}
		else
		{
			/*CHECK FOR AVAILBILITY*/	
			if(gu8_buzyflag==BUSY)
     562:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <gu8_buzyflag>
     566:	91 30       	cpi	r25, 0x01	; 1
     568:	99 f0       	breq	.+38     	; 0x590 <EEINT_ReqWrite+0x3c>
				au8_errorstate=EEINT_BUSY;
			}
			else
			{
				/*SAVE THE DATA ,ADRESS AND LENGTH TO USE THEM IN MAIN_FUNC*/
				gu8_startadress=StartAddress;
     56a:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <gu8_startadress>
				gau8_DataPtr=DataPtr;
     56e:	70 93 3e 01 	sts	0x013E, r23	; 0x80013e <gau8_DataPtr+0x1>
     572:	60 93 3d 01 	sts	0x013D, r22	; 0x80013d <gau8_DataPtr>
				gu8_Length=Length;
     576:	40 93 3a 01 	sts	0x013A, r20	; 0x80013a <gu8_Length>
			    /*CHANGE SM FOR WRITING STATE*/
				gu8_stateflag=WRITE_STATE;
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
				gu8_buzyflag=BUSY;
     580:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <gu8_buzyflag>
	gu8_initfalg=INITIALIZED;
}

EEINT_CheckType EEINT_ReqWrite(unsigned char StartAddress,unsigned char* DataPtr,unsigned char Length)
{
EEINT_CheckType au8_errorstate=EEINT_OK;
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	08 95       	ret
	/*CHECK FOR  VOID POINTER AND MOODULE INITIALIZED*/
	if((DataPtr==NULL)||(gu8_initfalg==UN_INITIALIZED))
	{
		au8_errorstate=EEINT_NOK;
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	08 95       	ret
     58c:	81 e0       	ldi	r24, 0x01	; 1
     58e:	08 95       	ret
		else
		{
			/*CHECK FOR AVAILBILITY*/	
			if(gu8_buzyflag==BUSY)
			{
				au8_errorstate=EEINT_BUSY;
     590:	82 e0       	ldi	r24, 0x02	; 2
			}
		}
		
	}
return au8_errorstate;	
}
     592:	08 95       	ret

00000594 <EEINT_ReqRead>:

EEINT_CheckType EEINT_ReqRead(unsigned char StartAddress, unsigned char* DataPtr,unsigned char Length)
{
EEINT_CheckType au8_errorstate=EEINT_OK;
/*CHECK FOR  VOID POINTER AND MOODULE INITIALIZED*/
if((DataPtr==NULL)||(gu8_initfalg==UN_INITIALIZED))
     594:	61 15       	cp	r22, r1
     596:	71 05       	cpc	r23, r1
     598:	c1 f0       	breq	.+48     	; 0x5ca <EEINT_ReqRead+0x36>
     59a:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <gu8_initfalg>
     59e:	99 23       	and	r25, r25
     5a0:	b1 f0       	breq	.+44     	; 0x5ce <EEINT_ReqRead+0x3a>
		au8_errorstate=EEINT_NOK;
	}
	else
	{
		/*CHECK FOR AVAILBILITY*/
		if(gu8_buzyflag==BUSY)
     5a2:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <gu8_buzyflag>
     5a6:	91 30       	cpi	r25, 0x01	; 1
     5a8:	a1 f0       	breq	.+40     	; 0x5d2 <EEINT_ReqRead+0x3e>
			au8_errorstate=EEINT_BUSY;
		}
		else
		{
			/*SAVE THE DATA ,ADRESS AND LENGTH TO USE THEM IN MAIN_FUNC*/
			gu8_startadress=StartAddress;
     5aa:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <gu8_startadress>
			gu8_readptr=DataPtr;
     5ae:	70 93 3c 01 	sts	0x013C, r23	; 0x80013c <gu8_readptr+0x1>
     5b2:	60 93 3b 01 	sts	0x013B, r22	; 0x80013b <gu8_readptr>
			gu8_Length=Length;
     5b6:	40 93 3a 01 	sts	0x013A, r20	; 0x80013a <gu8_Length>
			/*CHANGE SM FOR WRITING STATE*/
			gu8_stateflag=READ_STATE;
     5ba:	82 e0       	ldi	r24, 0x02	; 2
     5bc:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
			gu8_buzyflag=BUSY;
     5c0:	81 e0       	ldi	r24, 0x01	; 1
     5c2:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <gu8_buzyflag>
return au8_errorstate;	
}

EEINT_CheckType EEINT_ReqRead(unsigned char StartAddress, unsigned char* DataPtr,unsigned char Length)
{
EEINT_CheckType au8_errorstate=EEINT_OK;
     5c6:	80 e0       	ldi	r24, 0x00	; 0
     5c8:	08 95       	ret
/*CHECK FOR  VOID POINTER AND MOODULE INITIALIZED*/
if((DataPtr==NULL)||(gu8_initfalg==UN_INITIALIZED))
{
	au8_errorstate=EEINT_NOK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	08 95       	ret
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	08 95       	ret
	else
	{
		/*CHECK FOR AVAILBILITY*/
		if(gu8_buzyflag==BUSY)
		{
			au8_errorstate=EEINT_BUSY;
     5d2:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	
}
return au8_errorstate;
}
     5d4:	08 95       	ret

000005d6 <EEINT_Main>:
{
	static uint8_t au8_writecounter=0;
	static  uint8_t au8_readcounter=0;
	
	
	switch(gu8_stateflag)
     5d6:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <gu8_stateflag>
     5da:	82 30       	cpi	r24, 0x02	; 2
     5dc:	09 f4       	brne	.+2      	; 0x5e0 <EEINT_Main+0xa>
     5de:	44 c0       	rjmp	.+136    	; 0x668 <EEINT_Main+0x92>
     5e0:	28 f4       	brcc	.+10     	; 0x5ec <EEINT_Main+0x16>
     5e2:	88 23       	and	r24, r24
     5e4:	69 f0       	breq	.+26     	; 0x600 <EEINT_Main+0x2a>
     5e6:	81 30       	cpi	r24, 0x01	; 1
     5e8:	71 f0       	breq	.+28     	; 0x606 <EEINT_Main+0x30>
     5ea:	08 95       	ret
     5ec:	85 30       	cpi	r24, 0x05	; 5
     5ee:	09 f4       	brne	.+2      	; 0x5f2 <EEINT_Main+0x1c>
     5f0:	62 c0       	rjmp	.+196    	; 0x6b6 <EEINT_Main+0xe0>
     5f2:	86 30       	cpi	r24, 0x06	; 6
     5f4:	09 f4       	brne	.+2      	; 0x5f8 <EEINT_Main+0x22>
     5f6:	50 c0       	rjmp	.+160    	; 0x698 <EEINT_Main+0xc2>
     5f8:	84 30       	cpi	r24, 0x04	; 4
     5fa:	09 f0       	breq	.+2      	; 0x5fe <EEINT_Main+0x28>
     5fc:	63 c0       	rjmp	.+198    	; 0x6c4 <EEINT_Main+0xee>
     5fe:	2c c0       	rjmp	.+88     	; 0x658 <EEINT_Main+0x82>
	{
		case IDLE_STATE:
				  gu8_buzyflag=FREE;
     600:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <gu8_buzyflag>
				 
				  break;
     604:	08 95       	ret
		case WRITE_STATE:
		     if(au8_writecounter==gu8_Length)
     606:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <au8_writecounter.1660>
     60a:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <gu8_Length>
     60e:	98 13       	cpse	r25, r24
     610:	06 c0       	rjmp	.+12     	; 0x61e <EEINT_Main+0x48>
			 {
				 au8_writecounter=0;
     612:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <au8_writecounter.1660>
				 gu8_stateflag=WRITEN_COMPLETE;
     616:	84 e0       	ldi	r24, 0x04	; 4
     618:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
     61c:	08 95       	ret
			 }
			 else
			 {
				 cli(); 
     61e:	f8 94       	cli
				 EEDR=gau8_DataPtr[au8_writecounter]; 
     620:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <au8_writecounter.1660>
     624:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <gau8_DataPtr>
     628:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <gau8_DataPtr+0x1>
     62c:	e8 0f       	add	r30, r24
     62e:	f1 1d       	adc	r31, r1
     630:	80 81       	ld	r24, Z
     632:	8d bb       	out	0x1d, r24	; 29
				 au8_writecounter++;
     634:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <au8_writecounter.1660>
     638:	8f 5f       	subi	r24, 0xFF	; 255
     63a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <au8_writecounter.1660>
				 EEAR=gu8_startadress;
     63e:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <gu8_startadress>
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	9f bb       	out	0x1f, r25	; 31
     646:	8e bb       	out	0x1e, r24	; 30
				 EECR &=~(1<<EEWE);
     648:	e1 98       	cbi	0x1c, 1	; 28
				 EECR |= (1<<EEMWE);
     64a:	e2 9a       	sbi	0x1c, 2	; 28
				 /* Write logical one to EEMWE */
				 /* Start eeprom write by setting EEWE */
				 EECR |= (1<<EEWE);
     64c:	e1 9a       	sbi	0x1c, 1	; 28
				 gu8_stateflag=WRITING_STATE;
     64e:	83 e0       	ldi	r24, 0x03	; 3
     650:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
				 sei();
     654:	78 94       	sei
     656:	08 95       	ret
			 }
		     break;
		case WRITING_STATE:
		     break;	 
	    case WRITEN_COMPLETE:
		     EEINT_ConfigParam.WriteDoneCbkPtr();
     658:	e0 91 af 00 	lds	r30, 0x00AF	; 0x8000af <EEINT_ConfigParam>
     65c:	f0 91 b0 00 	lds	r31, 0x00B0	; 0x8000b0 <EEINT_ConfigParam+0x1>
     660:	09 95       	icall
			 gu8_stateflag=IDLE_STATE;
     662:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <gu8_stateflag>
			  break;
     666:	08 95       	ret
	    case READ_STATE:
		    
			if(au8_readcounter==gu8_Length)
     668:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <au8_readcounter.1661>
     66c:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <gu8_Length>
     670:	98 13       	cpse	r25, r24
     672:	06 c0       	rjmp	.+12     	; 0x680 <EEINT_Main+0xaa>
			{
				au8_readcounter=0;
     674:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <au8_readcounter.1661>
				gu8_stateflag=READ_COMPLETE;
     678:	85 e0       	ldi	r24, 0x05	; 5
     67a:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
     67e:	08 95       	ret
			}
			else
			{
				EEAR=gu8_startadress;
     680:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <gu8_startadress>
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	9f bb       	out	0x1f, r25	; 31
     688:	8e bb       	out	0x1e, r24	; 30
				EECR &=~(1<<EEMWE);
     68a:	e2 98       	cbi	0x1c, 2	; 28
				EECR &=~(1<<EEWE);
     68c:	e1 98       	cbi	0x1c, 1	; 28
				EECR |=(1<<EERE);		
     68e:	e0 9a       	sbi	0x1c, 0	; 28
				gu8_stateflag=READING_STATE;
     690:	86 e0       	ldi	r24, 0x06	; 6
     692:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
     696:	08 95       	ret
			}
			break;
	   case READING_STATE:      
	        if(gu8_READCOMPLETED==DONE)
     698:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <gu8_READCOMPLETED>
     69c:	81 30       	cpi	r24, 0x01	; 1
     69e:	91 f4       	brne	.+36     	; 0x6c4 <EEINT_Main+0xee>
			{
				gu8_READCOMPLETED=NOT_YET;
     6a0:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <gu8_READCOMPLETED>
				au8_readcounter++;
     6a4:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <au8_readcounter.1661>
     6a8:	8f 5f       	subi	r24, 0xFF	; 255
     6aa:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <au8_readcounter.1661>
				gu8_stateflag=READ_STATE;
     6ae:	82 e0       	ldi	r24, 0x02	; 2
     6b0:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
     6b4:	08 95       	ret
			}
			break;
     case  READ_COMPLETE:
			EEINT_ConfigParam.ReadDoneCbkPtr();
     6b6:	e0 91 b1 00 	lds	r30, 0x00B1	; 0x8000b1 <EEINT_ConfigParam+0x2>
     6ba:	f0 91 b2 00 	lds	r31, 0x00B2	; 0x8000b2 <EEINT_ConfigParam+0x3>
     6be:	09 95       	icall
			gu8_stateflag=IDLE_STATE;
     6c0:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <gu8_stateflag>
     6c4:	08 95       	ret

000006c6 <__vector_17>:
			break;
	    	  
	}
}
 ISR(EE_RDY_vect)
{
     6c6:	1f 92       	push	r1
     6c8:	0f 92       	push	r0
     6ca:	0f b6       	in	r0, 0x3f	; 63
     6cc:	0f 92       	push	r0
     6ce:	11 24       	eor	r1, r1
     6d0:	8f 93       	push	r24
     6d2:	9f 93       	push	r25
     6d4:	ef 93       	push	r30
     6d6:	ff 93       	push	r31
	if((gu8_stateflag==WRITING_STATE)||(gu8_stateflag==WRITE_STATE))
     6d8:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <gu8_stateflag>
     6dc:	98 2f       	mov	r25, r24
     6de:	9d 7f       	andi	r25, 0xFD	; 253
     6e0:	91 30       	cpi	r25, 0x01	; 1
     6e2:	21 f4       	brne	.+8      	; 0x6ec <__vector_17+0x26>
	{
		gu8_stateflag=WRITE_STATE;
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <gu8_stateflag>
     6ea:	0b c0       	rjmp	.+22     	; 0x702 <__vector_17+0x3c>
	}
	else if(gu8_stateflag==READING_STATE)
     6ec:	86 30       	cpi	r24, 0x06	; 6
     6ee:	49 f4       	brne	.+18     	; 0x702 <__vector_17+0x3c>
	{ 
		*gu8_readptr=EEDR;
     6f0:	8d b3       	in	r24, 0x1d	; 29
     6f2:	e0 91 3b 01 	lds	r30, 0x013B	; 0x80013b <gu8_readptr>
     6f6:	f0 91 3c 01 	lds	r31, 0x013C	; 0x80013c <gu8_readptr+0x1>
     6fa:	80 83       	st	Z, r24
		gu8_READCOMPLETED=DONE;	
     6fc:	81 e0       	ldi	r24, 0x01	; 1
     6fe:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <gu8_READCOMPLETED>
	}
	
     702:	ff 91       	pop	r31
     704:	ef 91       	pop	r30
     706:	9f 91       	pop	r25
     708:	8f 91       	pop	r24
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	0f 90       	pop	r0
     710:	1f 90       	pop	r1
     712:	18 95       	reti

00000714 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     71a:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     71e:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <xNextFreeByte>
     722:	30 91 45 01 	lds	r19, 0x0145	; 0x800145 <xNextFreeByte+0x1>
     726:	c9 01       	movw	r24, r18
     728:	8c 0f       	add	r24, r28
     72a:	9d 1f       	adc	r25, r29
     72c:	88 35       	cpi	r24, 0x58	; 88
     72e:	42 e0       	ldi	r20, 0x02	; 2
     730:	94 07       	cpc	r25, r20
     732:	58 f4       	brcc	.+22     	; 0x74a <pvPortMalloc+0x36>
     734:	28 17       	cp	r18, r24
     736:	39 07       	cpc	r19, r25
     738:	58 f4       	brcc	.+22     	; 0x750 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     73a:	e9 01       	movw	r28, r18
     73c:	ca 5b       	subi	r28, 0xBA	; 186
     73e:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     740:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <xNextFreeByte+0x1>
     744:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <xNextFreeByte>
     748:	05 c0       	rjmp	.+10     	; 0x754 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     74a:	c0 e0       	ldi	r28, 0x00	; 0
     74c:	d0 e0       	ldi	r29, 0x00	; 0
     74e:	02 c0       	rjmp	.+4      	; 0x754 <pvPortMalloc+0x40>
     750:	c0 e0       	ldi	r28, 0x00	; 0
     752:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     754:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     758:	ce 01       	movw	r24, r28
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     760:	08 95       	ret

00000762 <I2C_Init>:
    /* 
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
     762:	0f 93       	push	r16
     764:	1f 93       	push	r17
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	80 91 b7 00 	lds	r24, 0x00B7	; 0x8000b7 <I2C_ConfigParam+0x4>
     76e:	90 91 b8 00 	lds	r25, 0x00B8	; 0x8000b8 <I2C_ConfigParam+0x5>
     772:	81 30       	cpi	r24, 0x01	; 1
     774:	91 05       	cpc	r25, r1
     776:	49 f0       	breq	.+18     	; 0x78a <I2C_Init+0x28>
     778:	30 f0       	brcs	.+12     	; 0x786 <I2C_Init+0x24>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	91 05       	cpc	r25, r1
     77e:	39 f0       	breq	.+14     	; 0x78e <I2C_Init+0x2c>
     780:	03 97       	sbiw	r24, 0x03	; 3
     782:	39 f0       	breq	.+14     	; 0x792 <I2C_Init+0x30>
     784:	07 c0       	rjmp	.+14     	; 0x794 <I2C_Init+0x32>
     786:	60 e0       	ldi	r22, 0x00	; 0
     788:	05 c0       	rjmp	.+10     	; 0x794 <I2C_Init+0x32>
     78a:	61 e0       	ldi	r22, 0x01	; 1
     78c:	03 c0       	rjmp	.+6      	; 0x794 <I2C_Init+0x32>
     78e:	62 e0       	ldi	r22, 0x02	; 2
     790:	01 c0       	rjmp	.+2      	; 0x794 <I2C_Init+0x32>
     792:	63 e0       	ldi	r22, 0x03	; 3
     794:	d4 e0       	ldi	r29, 0x04	; 4
     796:	c6 2f       	mov	r28, r22
     798:	cd 27       	eor	r28, r29
     79a:	03 eb       	ldi	r16, 0xB3	; 179
     79c:	10 e0       	ldi	r17, 0x00	; 0
     79e:	f8 01       	movw	r30, r16
     7a0:	86 81       	ldd	r24, Z+6	; 0x06
     7a2:	97 81       	ldd	r25, Z+7	; 0x07
     7a4:	a0 85       	ldd	r26, Z+8	; 0x08
     7a6:	b1 85       	ldd	r27, Z+9	; 0x09
     7a8:	9c 01       	movw	r18, r24
     7aa:	ad 01       	movw	r20, r26
     7ac:	22 0f       	add	r18, r18
     7ae:	33 1f       	adc	r19, r19
     7b0:	44 1f       	adc	r20, r20
     7b2:	55 1f       	adc	r21, r21
     7b4:	ac 2f       	mov	r26, r28
     7b6:	b0 e0       	ldi	r27, 0x00	; 0
     7b8:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <__muluhisi3>
     7bc:	9b 01       	movw	r18, r22
     7be:	ac 01       	movw	r20, r24
     7c0:	60 81       	ld	r22, Z
     7c2:	71 81       	ldd	r23, Z+1	; 0x01
     7c4:	82 81       	ldd	r24, Z+2	; 0x02
     7c6:	93 81       	ldd	r25, Z+3	; 0x03
     7c8:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <__udivmodsi4>
     7cc:	6c 2f       	mov	r22, r28
     7ce:	70 e0       	ldi	r23, 0x00	; 0
     7d0:	66 0f       	add	r22, r22
     7d2:	77 1f       	adc	r23, r23
     7d4:	80 e1       	ldi	r24, 0x10	; 16
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__divmodhi4>
     7dc:	26 1b       	sub	r18, r22
     7de:	20 b9       	out	0x00, r18	; 0
     7e0:	11 b8       	out	0x01, r1	; 1
     7e2:	80 e1       	ldi	r24, 0x10	; 16
     7e4:	82 b9       	out	0x02, r24	; 2
     7e6:	d6 bf       	out	0x36, r29	; 54
     7e8:	f8 01       	movw	r30, r16
     7ea:	82 85       	ldd	r24, Z+10	; 0x0a
     7ec:	93 85       	ldd	r25, Z+11	; 0x0b
     7ee:	90 93 9f 03 	sts	0x039F, r25	; 0x80039f <Clb_Ptr+0x1>
     7f2:	80 93 9e 03 	sts	0x039E, r24	; 0x80039e <Clb_Ptr>
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	1f 91       	pop	r17
     7fc:	0f 91       	pop	r16
     7fe:	08 95       	ret

00000800 <I2C_ReqWrite>:
* Parameters (out): None
* Return value: I2C_CheckType
* Description: this function writes data on I2C bus
************************************************************************************/
I2C_CheckType I2C_ReqWrite(unsigned char SlaveAddress, const unsigned char* DataPtr, unsigned char DataLen)
{
     800:	fb 01       	movw	r30, r22
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
     802:	44 23       	and	r20, r20
     804:	b1 f0       	breq	.+44     	; 0x832 <I2C_ReqWrite+0x32>
     806:	90 e0       	ldi	r25, 0x00	; 0
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     808:	54 ea       	ldi	r21, 0xA4	; 164
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
		{
			I2C_start();
			TWDR = SlaveAddress & WRITE_MASK;   /* slave address and write operation */
     80a:	8e 7f       	andi	r24, 0xFE	; 254

		/*
		 * Clear the TWINT flag before sending the data TWINT=1
		 * Enable TWI Module TWEN=1
		 */
		TWCR = (1 << TWINT) | (1 << TWEN);
     80c:	34 e8       	ldi	r19, 0x84	; 132
{
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
     80e:	91 11       	cpse	r25, r1
     810:	06 c0       	rjmp	.+12     	; 0x81e <I2C_ReqWrite+0x1e>
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     812:	56 bf       	out	0x36, r21	; 54
    
    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
     814:	06 b6       	in	r0, 0x36	; 54
     816:	07 fe       	sbrs	r0, 7
     818:	fd cf       	rjmp	.-6      	; 0x814 <I2C_ReqWrite+0x14>
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
		{
			I2C_start();
			TWDR = SlaveAddress & WRITE_MASK;   /* slave address and write operation */
     81a:	83 b9       	out	0x03, r24	; 3
     81c:	03 c0       	rjmp	.+6      	; 0x824 <I2C_ReqWrite+0x24>

		else
		{
			//softwareDelayUS(10);
			/* Put data On TWI data Register */
			TWDR = *DataPtr;
     81e:	21 91       	ld	r18, Z+
     820:	23 b9       	out	0x03, r18	; 3

			DataLen--;
     822:	41 50       	subi	r20, 0x01	; 1

		/*
		 * Clear the TWINT flag before sending the data TWINT=1
		 * Enable TWI Module TWEN=1
		 */
		TWCR = (1 << TWINT) | (1 << TWEN);
     824:	36 bf       	out	0x36, r19	; 54

		/* Wait for TWINT flag set in TWCR Register(data is send successfully) */
		while(BIT_IS_CLEAR(TWCR,TWINT));
     826:	06 b6       	in	r0, 0x36	; 54
     828:	07 fe       	sbrs	r0, 7
     82a:	fd cf       	rjmp	.-6      	; 0x826 <I2C_ReqWrite+0x26>

		au8_counter++;
     82c:	9f 5f       	subi	r25, 0xFF	; 255
************************************************************************************/
I2C_CheckType I2C_ReqWrite(unsigned char SlaveAddress, const unsigned char* DataPtr, unsigned char DataLen)
{
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
     82e:	41 11       	cpse	r20, r1
     830:	ee cf       	rjmp	.-36     	; 0x80e <I2C_ReqWrite+0xe>
		while(BIT_IS_CLEAR(TWCR,TWINT));

		au8_counter++;
	}

	if(Clb_Ptr != NULL)
     832:	e0 91 9e 03 	lds	r30, 0x039E	; 0x80039e <Clb_Ptr>
     836:	f0 91 9f 03 	lds	r31, 0x039F	; 0x80039f <Clb_Ptr+0x1>
     83a:	30 97       	sbiw	r30, 0x00	; 0
     83c:	09 f0       	breq	.+2      	; 0x840 <I2C_ReqWrite+0x40>
	{
		Clb_Ptr();  /* notify the consumer */
     83e:	09 95       	icall
	}
	return au8_stats;
}
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	08 95       	ret

00000844 <I2C_ReqRead>:
* Parameters (out): - *DataPtr
* Return value: I2C_CheckType
* Description: this function writes data on I2C bus
************************************************************************************/
I2C_CheckType I2C_ReqRead(unsigned char SlaveAddress, unsigned char* DataPtr, unsigned char DataLen)
{
     844:	fb 01       	movw	r30, r22
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
     846:	44 23       	and	r20, r20
     848:	d9 f0       	breq	.+54     	; 0x880 <__stack+0x21>
     84a:	90 e0       	ldi	r25, 0x00	; 0
			/*
			 * Clear the TWINT flag before reading the data TWINT=1
			 * Enable sending ACK after reading or receiving data TWEA=1
			 * Enable TWI Module TWEN=1
			 */
			TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
     84c:	34 ec       	ldi	r19, 0xC4	; 196
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     84e:	64 ea       	ldi	r22, 0xA4	; 164
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
		{
			I2C_start();
			TWDR = SlaveAddress | READ_MASK;   /* slave address and read operation */
     850:	81 60       	ori	r24, 0x01	; 1

			/*
			 * Clear the TWINT flag before sending the data TWINT=1
			 * Enable TWI Module TWEN=1
			 */
			TWCR = (1 << TWINT) | (1 << TWEN);
     852:	54 e8       	ldi	r21, 0x84	; 132
{
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
     854:	91 11       	cpse	r25, r1
     856:	0a c0       	rjmp	.+20     	; 0x86c <__stack+0xd>
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     858:	66 bf       	out	0x36, r22	; 54
    
    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
     85a:	06 b6       	in	r0, 0x36	; 54
     85c:	07 fe       	sbrs	r0, 7
     85e:	fd cf       	rjmp	.-6      	; 0x85a <I2C_ReqRead+0x16>
	while(DataLen != END)
	{
		if(au8_counter == FIRST_ENTRY)
		{
			I2C_start();
			TWDR = SlaveAddress | READ_MASK;   /* slave address and read operation */
     860:	83 b9       	out	0x03, r24	; 3

			/*
			 * Clear the TWINT flag before sending the data TWINT=1
			 * Enable TWI Module TWEN=1
			 */
			TWCR = (1 << TWINT) | (1 << TWEN);
     862:	56 bf       	out	0x36, r21	; 54

			/* Wait for TWINT flag set in TWCR Register(data is send successfully) */
			while(BIT_IS_CLEAR(TWCR,TWINT));
     864:	06 b6       	in	r0, 0x36	; 54
     866:	07 fe       	sbrs	r0, 7
     868:	fd cf       	rjmp	.-6      	; 0x864 <__stack+0x5>
     86a:	07 c0       	rjmp	.+14     	; 0x87a <__stack+0x1b>
			/*
			 * Clear the TWINT flag before reading the data TWINT=1
			 * Enable sending ACK after reading or receiving data TWEA=1
			 * Enable TWI Module TWEN=1
			 */
			TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
     86c:	36 bf       	out	0x36, r19	; 54
			/* Wait for TWINT flag set in TWCR Register (data received successfully) */
			while(BIT_IS_CLEAR(TWCR,TWINT));
     86e:	06 b6       	in	r0, 0x36	; 54
     870:	07 fe       	sbrs	r0, 7
     872:	fd cf       	rjmp	.-6      	; 0x86e <__stack+0xf>
			/* Read Data */
			*DataPtr = TWDR;
     874:	23 b1       	in	r18, 0x03	; 3
     876:	21 93       	st	Z+, r18

			DataLen--;
     878:	41 50       	subi	r20, 0x01	; 1
			DataPtr++;
		}
		au8_counter++;
     87a:	9f 5f       	subi	r25, 0xFF	; 255
************************************************************************************/
I2C_CheckType I2C_ReqRead(unsigned char SlaveAddress, unsigned char* DataPtr, unsigned char DataLen)
{
	uint8_t au8_stats = I2C_OK;
	uint8_t au8_counter = CLEAR;
	while(DataLen != END)
     87c:	41 11       	cpse	r20, r1
     87e:	ea cf       	rjmp	.-44     	; 0x854 <I2C_ReqRead+0x10>
			DataPtr++;
		}
		au8_counter++;
	}

	if(Clb_Ptr != NULL)
     880:	e0 91 9e 03 	lds	r30, 0x039E	; 0x80039e <Clb_Ptr>
     884:	f0 91 9f 03 	lds	r31, 0x039F	; 0x80039f <Clb_Ptr+0x1>
     888:	30 97       	sbiw	r30, 0x00	; 0
     88a:	09 f0       	breq	.+2      	; 0x88e <__stack+0x2f>
	{
		Clb_Ptr();    /* notify the consumer */
     88c:	09 95       	icall
	}
	return au8_stats;
}
     88e:	80 e0       	ldi	r24, 0x00	; 0
     890:	08 95       	ret

00000892 <_delay_us>:
		DIO_Write(lut[Loop],BitValue);
	}
}

static void _delay_us(unsigned long int Count)
{
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
     89a:	28 97       	sbiw	r28, 0x08	; 8
     89c:	0f b6       	in	r0, 0x3f	; 63
     89e:	f8 94       	cli
     8a0:	de bf       	out	0x3e, r29	; 62
     8a2:	0f be       	out	0x3f, r0	; 63
     8a4:	cd bf       	out	0x3d, r28	; 61
     8a6:	ab 01       	movw	r20, r22
     8a8:	bc 01       	movw	r22, r24
 volatile unsigned long int Loop1;
 volatile unsigned long int loop2;
 for(Loop1 = 0; Loop1 < Count; Loop1++)
     8aa:	19 82       	std	Y+1, r1	; 0x01
     8ac:	1a 82       	std	Y+2, r1	; 0x02
     8ae:	1b 82       	std	Y+3, r1	; 0x03
     8b0:	1c 82       	std	Y+4, r1	; 0x04
     8b2:	89 81       	ldd	r24, Y+1	; 0x01
     8b4:	9a 81       	ldd	r25, Y+2	; 0x02
     8b6:	ab 81       	ldd	r26, Y+3	; 0x03
     8b8:	bc 81       	ldd	r27, Y+4	; 0x04
     8ba:	84 17       	cp	r24, r20
     8bc:	95 07       	cpc	r25, r21
     8be:	a6 07       	cpc	r26, r22
     8c0:	b7 07       	cpc	r27, r23
     8c2:	98 f5       	brcc	.+102    	; 0x92a <_delay_us+0x98>
 {
     for(loop2 = 0; loop2 < 4; loop2++);
     8c4:	1d 82       	std	Y+5, r1	; 0x05
     8c6:	1e 82       	std	Y+6, r1	; 0x06
     8c8:	1f 82       	std	Y+7, r1	; 0x07
     8ca:	18 86       	std	Y+8, r1	; 0x08
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	9e 81       	ldd	r25, Y+6	; 0x06
     8d0:	af 81       	ldd	r26, Y+7	; 0x07
     8d2:	b8 85       	ldd	r27, Y+8	; 0x08
     8d4:	04 97       	sbiw	r24, 0x04	; 4
     8d6:	a1 05       	cpc	r26, r1
     8d8:	b1 05       	cpc	r27, r1
     8da:	98 f4       	brcc	.+38     	; 0x902 <_delay_us+0x70>
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	9e 81       	ldd	r25, Y+6	; 0x06
     8e0:	af 81       	ldd	r26, Y+7	; 0x07
     8e2:	b8 85       	ldd	r27, Y+8	; 0x08
     8e4:	01 96       	adiw	r24, 0x01	; 1
     8e6:	a1 1d       	adc	r26, r1
     8e8:	b1 1d       	adc	r27, r1
     8ea:	8d 83       	std	Y+5, r24	; 0x05
     8ec:	9e 83       	std	Y+6, r25	; 0x06
     8ee:	af 83       	std	Y+7, r26	; 0x07
     8f0:	b8 87       	std	Y+8, r27	; 0x08
     8f2:	8d 81       	ldd	r24, Y+5	; 0x05
     8f4:	9e 81       	ldd	r25, Y+6	; 0x06
     8f6:	af 81       	ldd	r26, Y+7	; 0x07
     8f8:	b8 85       	ldd	r27, Y+8	; 0x08
     8fa:	04 97       	sbiw	r24, 0x04	; 4
     8fc:	a1 05       	cpc	r26, r1
     8fe:	b1 05       	cpc	r27, r1
     900:	68 f3       	brcs	.-38     	; 0x8dc <_delay_us+0x4a>

static void _delay_us(unsigned long int Count)
{
 volatile unsigned long int Loop1;
 volatile unsigned long int loop2;
 for(Loop1 = 0; Loop1 < Count; Loop1++)
     902:	89 81       	ldd	r24, Y+1	; 0x01
     904:	9a 81       	ldd	r25, Y+2	; 0x02
     906:	ab 81       	ldd	r26, Y+3	; 0x03
     908:	bc 81       	ldd	r27, Y+4	; 0x04
     90a:	01 96       	adiw	r24, 0x01	; 1
     90c:	a1 1d       	adc	r26, r1
     90e:	b1 1d       	adc	r27, r1
     910:	89 83       	std	Y+1, r24	; 0x01
     912:	9a 83       	std	Y+2, r25	; 0x02
     914:	ab 83       	std	Y+3, r26	; 0x03
     916:	bc 83       	std	Y+4, r27	; 0x04
     918:	89 81       	ldd	r24, Y+1	; 0x01
     91a:	9a 81       	ldd	r25, Y+2	; 0x02
     91c:	ab 81       	ldd	r26, Y+3	; 0x03
     91e:	bc 81       	ldd	r27, Y+4	; 0x04
     920:	84 17       	cp	r24, r20
     922:	95 07       	cpc	r25, r21
     924:	a6 07       	cpc	r26, r22
     926:	b7 07       	cpc	r27, r23
     928:	68 f2       	brcs	.-102    	; 0x8c4 <_delay_us+0x32>
 {
     for(loop2 = 0; loop2 < 4; loop2++);
 }

}
     92a:	28 96       	adiw	r28, 0x08	; 8
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	de bf       	out	0x3e, r29	; 62
     932:	0f be       	out	0x3f, r0	; 63
     934:	cd bf       	out	0x3d, r28	; 61
     936:	df 91       	pop	r29
     938:	cf 91       	pop	r28
     93a:	08 95       	ret

0000093c <WriteNipple>:
	


}
static void WriteNipple(unsigned char Nipple)
{
     93c:	af 92       	push	r10
     93e:	bf 92       	push	r11
     940:	cf 92       	push	r12
     942:	df 92       	push	r13
     944:	ef 92       	push	r14
     946:	ff 92       	push	r15
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	00 d0       	rcall	.+0      	; 0x952 <WriteNipple+0x16>
     952:	00 d0       	rcall	.+0      	; 0x954 <WriteNipple+0x18>
     954:	cd b7       	in	r28, 0x3d	; 61
     956:	de b7       	in	r29, 0x3e	; 62
	unsigned char Loop;
	unsigned char BitValue;
	unsigned char lut[4] = {LCD_DATA0, LCD_DATA1, LCD_DATA2, LCD_DATA3};
     958:	96 e0       	ldi	r25, 0x06	; 6
     95a:	99 83       	std	Y+1, r25	; 0x01
     95c:	97 e0       	ldi	r25, 0x07	; 7
     95e:	9a 83       	std	Y+2, r25	; 0x02
     960:	98 e0       	ldi	r25, 0x08	; 8
     962:	9b 83       	std	Y+3, r25	; 0x03
     964:	99 e0       	ldi	r25, 0x09	; 9
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	9e 01       	movw	r18, r28
     96a:	2f 5f       	subi	r18, 0xFF	; 255
     96c:	3f 4f       	sbci	r19, 0xFF	; 255
     96e:	79 01       	movw	r14, r18
     970:	00 e0       	ldi	r16, 0x00	; 0
     972:	10 e0       	ldi	r17, 0x00	; 0
	for(Loop = 0; Loop < 4; Loop++)
	{
		BitValue = (Nipple & (1 << Loop)) >> Loop;
     974:	aa 24       	eor	r10, r10
     976:	a3 94       	inc	r10
     978:	b1 2c       	mov	r11, r1
     97a:	c8 2e       	mov	r12, r24
     97c:	d1 2c       	mov	r13, r1
     97e:	b5 01       	movw	r22, r10
     980:	00 2e       	mov	r0, r16
     982:	02 c0       	rjmp	.+4      	; 0x988 <WriteNipple+0x4c>
     984:	66 0f       	add	r22, r22
     986:	77 1f       	adc	r23, r23
     988:	0a 94       	dec	r0
     98a:	e2 f7       	brpl	.-8      	; 0x984 <WriteNipple+0x48>
     98c:	6c 21       	and	r22, r12
     98e:	7d 21       	and	r23, r13
     990:	00 2e       	mov	r0, r16
     992:	02 c0       	rjmp	.+4      	; 0x998 <WriteNipple+0x5c>
     994:	75 95       	asr	r23
     996:	67 95       	ror	r22
     998:	0a 94       	dec	r0
     99a:	e2 f7       	brpl	.-8      	; 0x994 <WriteNipple+0x58>
		BitValue = 0 - BitValue;
		DIO_Write(lut[Loop],BitValue);
     99c:	61 95       	neg	r22
     99e:	f7 01       	movw	r30, r14
     9a0:	81 91       	ld	r24, Z+
     9a2:	7f 01       	movw	r14, r30
     9a4:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>
     9a8:	0f 5f       	subi	r16, 0xFF	; 255
     9aa:	1f 4f       	sbci	r17, 0xFF	; 255
static void WriteNipple(unsigned char Nipple)
{
	unsigned char Loop;
	unsigned char BitValue;
	unsigned char lut[4] = {LCD_DATA0, LCD_DATA1, LCD_DATA2, LCD_DATA3};
	for(Loop = 0; Loop < 4; Loop++)
     9ac:	04 30       	cpi	r16, 0x04	; 4
     9ae:	11 05       	cpc	r17, r1
     9b0:	31 f7       	brne	.-52     	; 0x97e <WriteNipple+0x42>
	{
		BitValue = (Nipple & (1 << Loop)) >> Loop;
		BitValue = 0 - BitValue;
		DIO_Write(lut[Loop],BitValue);
	}
}
     9b2:	0f 90       	pop	r0
     9b4:	0f 90       	pop	r0
     9b6:	0f 90       	pop	r0
     9b8:	0f 90       	pop	r0
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	1f 91       	pop	r17
     9c0:	0f 91       	pop	r16
     9c2:	ff 90       	pop	r15
     9c4:	ef 90       	pop	r14
     9c6:	df 90       	pop	r13
     9c8:	cf 90       	pop	r12
     9ca:	bf 90       	pop	r11
     9cc:	af 90       	pop	r10
     9ce:	08 95       	ret

000009d0 <enableTrigger>:
void enableTrigger(void)
{



	DIO_Write(LCD_EN,0xff);
     9d0:	6f ef       	ldi	r22, 0xFF	; 255
     9d2:	85 e0       	ldi	r24, 0x05	; 5
     9d4:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>
	_delay_us(2);
     9d8:	62 e0       	ldi	r22, 0x02	; 2
     9da:	70 e0       	ldi	r23, 0x00	; 0
     9dc:	80 e0       	ldi	r24, 0x00	; 0
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	0e 94 49 04 	call	0x892	; 0x892 <_delay_us>
	DIO_Write(LCD_EN,0x00);
     9e4:	60 e0       	ldi	r22, 0x00	; 0
     9e6:	85 e0       	ldi	r24, 0x05	; 5
     9e8:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>
	_delay_us(2);
     9ec:	62 e0       	ldi	r22, 0x02	; 2
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	80 e0       	ldi	r24, 0x00	; 0
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	0e 94 49 04 	call	0x892	; 0x892 <_delay_us>
     9f8:	08 95       	ret

000009fa <lcd_sendCommand>:
	
}


void lcd_sendCommand(unsigned char cmd)
{
     9fa:	cf 93       	push	r28
     9fc:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ;
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	DIO_Write(LCD_RS,0x00);
     9fe:	60 e0       	ldi	r22, 0x00	; 0
     a00:	83 e0       	ldi	r24, 0x03	; 3
     a02:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>
	DIO_Write(LCD_WR,0x00);
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	84 e0       	ldi	r24, 0x04	; 4
     a0a:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>

	WriteNipple(high_nibble);
     a0e:	8c 2f       	mov	r24, r28
     a10:	82 95       	swap	r24
     a12:	8f 70       	andi	r24, 0x0F	; 15
     a14:	0e 94 9e 04 	call	0x93c	; 0x93c <WriteNipple>
	enableTrigger(); // triggre lcd enable
     a18:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <enableTrigger>
	_delay_us(10);
     a1c:	6a e0       	ldi	r22, 0x0A	; 10
     a1e:	70 e0       	ldi	r23, 0x00	; 0
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	0e 94 49 04 	call	0x892	; 0x892 <_delay_us>
	WriteNipple(low_nibble);
     a28:	8c 2f       	mov	r24, r28
     a2a:	8f 70       	andi	r24, 0x0F	; 15
     a2c:	0e 94 9e 04 	call	0x93c	; 0x93c <WriteNipple>
	enableTrigger();
     a30:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <enableTrigger>
	_delay_us(100);
     a34:	64 e6       	ldi	r22, 0x64	; 100
     a36:	70 e0       	ldi	r23, 0x00	; 0
     a38:	80 e0       	ldi	r24, 0x00	; 0
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	0e 94 49 04 	call	0x892	; 0x892 <_delay_us>

}
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <lcd_init>:
void lcd_init(void)
{



	lcd_sendCommand(0x33); // 4-bit mode
     a44:	83 e3       	ldi	r24, 0x33	; 51
     a46:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
	lcd_sendCommand (0x32);
     a4a:	82 e3       	ldi	r24, 0x32	; 50
     a4c:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
	lcd_sendCommand (0x28);
     a50:	88 e2       	ldi	r24, 0x28	; 40
     a52:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
	lcd_sendCommand(0x0c); // turn on lcd
     a56:	8c e0       	ldi	r24, 0x0C	; 12
     a58:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
     a5c:	08 95       	ret

00000a5e <lcd_displayChar>:
	_delay_us(100);

}

void lcd_displayChar (unsigned char data)
{
     a5e:	cf 93       	push	r28
     a60:	c8 2f       	mov	r28, r24


	HIGH_NIBBLE(high_nibble,data); // get high nibble data
	LOW_NIBBLE(low_nibble,data); // get low nibble data
	
	DIO_Write(LCD_RS,0xff);
     a62:	6f ef       	ldi	r22, 0xFF	; 255
     a64:	83 e0       	ldi	r24, 0x03	; 3
     a66:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>
	DIO_Write(LCD_WR,0x00);
     a6a:	60 e0       	ldi	r22, 0x00	; 0
     a6c:	84 e0       	ldi	r24, 0x04	; 4
     a6e:	0e 94 9f 01 	call	0x33e	; 0x33e <DIO_Write>

	WriteNipple(high_nibble);
     a72:	8c 2f       	mov	r24, r28
     a74:	82 95       	swap	r24
     a76:	8f 70       	andi	r24, 0x0F	; 15
     a78:	0e 94 9e 04 	call	0x93c	; 0x93c <WriteNipple>
	enableTrigger(); // triggre lcd enable
     a7c:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <enableTrigger>

	WriteNipple(low_nibble);
     a80:	8c 2f       	mov	r24, r28
     a82:	8f 70       	andi	r24, 0x0F	; 15
     a84:	0e 94 9e 04 	call	0x93c	; 0x93c <WriteNipple>
	enableTrigger();
     a88:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <enableTrigger>
	_delay_us(2);
     a8c:	62 e0       	ldi	r22, 0x02	; 2
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	80 e0       	ldi	r24, 0x00	; 0
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	0e 94 49 04 	call	0x892	; 0x892 <_delay_us>
	

}
     a98:	cf 91       	pop	r28
     a9a:	08 95       	ret

00000a9c <lcd_gotoxy>:

void lcd_gotoxy(unsigned char u8_posx , unsigned char u8_posy )
{
	unsigned char DDRAMA=0;
	// remap lines into proper order
	switch(u8_posy)
     a9c:	66 23       	and	r22, r22
     a9e:	29 f0       	breq	.+10     	; 0xaaa <lcd_gotoxy+0xe>
     aa0:	61 30       	cpi	r22, 0x01	; 1
     aa2:	11 f4       	brne	.+4      	; 0xaa8 <lcd_gotoxy+0xc>
	{
		case 0:
		DDRAMA = LCD_LINE0+u8_posx;
		break;
		case 1:
		DDRAMA = LCD_LINE1+u8_posx;
     aa4:	80 5c       	subi	r24, 0xC0	; 192
		break;
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <lcd_gotoxy+0xe>
}


void lcd_gotoxy(unsigned char u8_posx , unsigned char u8_posy )
{
	unsigned char DDRAMA=0;
     aa8:	80 e0       	ldi	r24, 0x00	; 0
		break;
		default:
		break;
	}
	// set data address
	lcd_sendCommand(1<<LCD_DDRAM | DDRAMA);
     aaa:	80 68       	ori	r24, 0x80	; 128
     aac:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
     ab0:	08 95       	ret

00000ab2 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	0e 94 fd 04 	call	0x9fa	; 0x9fa <lcd_sendCommand>
     ab8:	08 95       	ret

00000aba <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
     aba:	cf 93       	push	r28
     abc:	df 93       	push	r29
     abe:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     ac0:	88 81       	ld	r24, Y
     ac2:	88 23       	and	r24, r24
     ac4:	31 f0       	breq	.+12     	; 0xad2 <lcd_dispString+0x18>
     ac6:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
     ac8:	0e 94 2f 05 	call	0xa5e	; 0xa5e <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     acc:	89 91       	ld	r24, Y+
     ace:	81 11       	cpse	r24, r1
     ad0:	fb cf       	rjmp	.-10     	; 0xac8 <lcd_dispString+0xe>
		
	}



}
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
     ad6:	08 95       	ret

00000ad8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     ad8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     ada:	03 96       	adiw	r24, 0x03	; 3
     adc:	92 83       	std	Z+2, r25	; 0x02
     ade:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ae0:	2f ef       	ldi	r18, 0xFF	; 255
     ae2:	3f ef       	ldi	r19, 0xFF	; 255
     ae4:	34 83       	std	Z+4, r19	; 0x04
     ae6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     ae8:	96 83       	std	Z+6, r25	; 0x06
     aea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     aec:	90 87       	std	Z+8, r25	; 0x08
     aee:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     af0:	10 82       	st	Z, r1
     af2:	08 95       	ret

00000af4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     af4:	fc 01       	movw	r30, r24
     af6:	11 86       	std	Z+9, r1	; 0x09
     af8:	10 86       	std	Z+8, r1	; 0x08
     afa:	08 95       	ret

00000afc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
     b00:	fc 01       	movw	r30, r24
     b02:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     b04:	21 81       	ldd	r18, Z+1	; 0x01
     b06:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     b08:	e9 01       	movw	r28, r18
     b0a:	8a 81       	ldd	r24, Y+2	; 0x02
     b0c:	9b 81       	ldd	r25, Y+3	; 0x03
     b0e:	13 96       	adiw	r26, 0x03	; 3
     b10:	9c 93       	st	X, r25
     b12:	8e 93       	st	-X, r24
     b14:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     b16:	81 81       	ldd	r24, Z+1	; 0x01
     b18:	92 81       	ldd	r25, Z+2	; 0x02
     b1a:	15 96       	adiw	r26, 0x05	; 5
     b1c:	9c 93       	st	X, r25
     b1e:	8e 93       	st	-X, r24
     b20:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b22:	8a 81       	ldd	r24, Y+2	; 0x02
     b24:	9b 81       	ldd	r25, Y+3	; 0x03
     b26:	ec 01       	movw	r28, r24
     b28:	7d 83       	std	Y+5, r23	; 0x05
     b2a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     b2c:	e9 01       	movw	r28, r18
     b2e:	7b 83       	std	Y+3, r23	; 0x03
     b30:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     b32:	72 83       	std	Z+2, r23	; 0x02
     b34:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b36:	19 96       	adiw	r26, 0x09	; 9
     b38:	fc 93       	st	X, r31
     b3a:	ee 93       	st	-X, r30
     b3c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     b3e:	80 81       	ld	r24, Z
     b40:	8f 5f       	subi	r24, 0xFF	; 255
     b42:	80 83       	st	Z, r24
}
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	08 95       	ret

00000b4a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     b4a:	cf 93       	push	r28
     b4c:	df 93       	push	r29
     b4e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     b50:	48 81       	ld	r20, Y
     b52:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     b54:	4f 3f       	cpi	r20, 0xFF	; 255
     b56:	2f ef       	ldi	r18, 0xFF	; 255
     b58:	52 07       	cpc	r21, r18
     b5a:	31 f4       	brne	.+12     	; 0xb68 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     b5c:	dc 01       	movw	r26, r24
     b5e:	17 96       	adiw	r26, 0x07	; 7
     b60:	ed 91       	ld	r30, X+
     b62:	fc 91       	ld	r31, X
     b64:	18 97       	sbiw	r26, 0x08	; 8
     b66:	17 c0       	rjmp	.+46     	; 0xb96 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     b68:	fc 01       	movw	r30, r24
     b6a:	33 96       	adiw	r30, 0x03	; 3
     b6c:	dc 01       	movw	r26, r24
     b6e:	15 96       	adiw	r26, 0x05	; 5
     b70:	2d 91       	ld	r18, X+
     b72:	3c 91       	ld	r19, X
     b74:	16 97       	sbiw	r26, 0x06	; 6
     b76:	d9 01       	movw	r26, r18
     b78:	2d 91       	ld	r18, X+
     b7a:	3c 91       	ld	r19, X
     b7c:	42 17       	cp	r20, r18
     b7e:	53 07       	cpc	r21, r19
     b80:	50 f0       	brcs	.+20     	; 0xb96 <vListInsert+0x4c>
     b82:	02 80       	ldd	r0, Z+2	; 0x02
     b84:	f3 81       	ldd	r31, Z+3	; 0x03
     b86:	e0 2d       	mov	r30, r0
     b88:	a2 81       	ldd	r26, Z+2	; 0x02
     b8a:	b3 81       	ldd	r27, Z+3	; 0x03
     b8c:	2d 91       	ld	r18, X+
     b8e:	3c 91       	ld	r19, X
     b90:	42 17       	cp	r20, r18
     b92:	53 07       	cpc	r21, r19
     b94:	b0 f7       	brcc	.-20     	; 0xb82 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b96:	a2 81       	ldd	r26, Z+2	; 0x02
     b98:	b3 81       	ldd	r27, Z+3	; 0x03
     b9a:	bb 83       	std	Y+3, r27	; 0x03
     b9c:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b9e:	15 96       	adiw	r26, 0x05	; 5
     ba0:	dc 93       	st	X, r29
     ba2:	ce 93       	st	-X, r28
     ba4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     ba6:	fd 83       	std	Y+5, r31	; 0x05
     ba8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     baa:	d3 83       	std	Z+3, r29	; 0x03
     bac:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bae:	99 87       	std	Y+9, r25	; 0x09
     bb0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     bb2:	fc 01       	movw	r30, r24
     bb4:	20 81       	ld	r18, Z
     bb6:	2f 5f       	subi	r18, 0xFF	; 255
     bb8:	20 83       	st	Z, r18
}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     bc0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     bc2:	a2 81       	ldd	r26, Z+2	; 0x02
     bc4:	b3 81       	ldd	r27, Z+3	; 0x03
     bc6:	84 81       	ldd	r24, Z+4	; 0x04
     bc8:	95 81       	ldd	r25, Z+5	; 0x05
     bca:	15 96       	adiw	r26, 0x05	; 5
     bcc:	9c 93       	st	X, r25
     bce:	8e 93       	st	-X, r24
     bd0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     bd2:	a4 81       	ldd	r26, Z+4	; 0x04
     bd4:	b5 81       	ldd	r27, Z+5	; 0x05
     bd6:	82 81       	ldd	r24, Z+2	; 0x02
     bd8:	93 81       	ldd	r25, Z+3	; 0x03
     bda:	13 96       	adiw	r26, 0x03	; 3
     bdc:	9c 93       	st	X, r25
     bde:	8e 93       	st	-X, r24
     be0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     be2:	a0 85       	ldd	r26, Z+8	; 0x08
     be4:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     be6:	11 96       	adiw	r26, 0x01	; 1
     be8:	8d 91       	ld	r24, X+
     bea:	9c 91       	ld	r25, X
     bec:	12 97       	sbiw	r26, 0x02	; 2
     bee:	e8 17       	cp	r30, r24
     bf0:	f9 07       	cpc	r31, r25
     bf2:	31 f4       	brne	.+12     	; 0xc00 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     bf4:	84 81       	ldd	r24, Z+4	; 0x04
     bf6:	95 81       	ldd	r25, Z+5	; 0x05
     bf8:	12 96       	adiw	r26, 0x02	; 2
     bfa:	9c 93       	st	X, r25
     bfc:	8e 93       	st	-X, r24
     bfe:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     c00:	11 86       	std	Z+9, r1	; 0x09
     c02:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     c04:	8c 91       	ld	r24, X
     c06:	81 50       	subi	r24, 0x01	; 1
     c08:	8c 93       	st	X, r24
     c0a:	08 95       	ret

00000c0c <Main_WriteAllDone>:

void Main_Init(void)
{
	SystemState = STATE_IDLE;
	ReadAllDone = 0;
	WriteAllDone = 0;
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	80 93 a0 03 	sts	0x03A0, r24	; 0x8003a0 <WriteAllDone>
     c12:	08 95       	ret

00000c14 <Main_ReadAllDone>:
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	80 93 a1 03 	sts	0x03A1, r24	; 0x8003a1 <ReadAllDone>
     c1a:	08 95       	ret

00000c1c <main>:
     c1c:	0e 94 72 01 	call	0x2e4	; 0x2e4 <DIO_Init>
     c20:	0e 94 b1 03 	call	0x762	; 0x762 <I2C_Init>
     c24:	0e 94 a5 02 	call	0x54a	; 0x54a <EEINT_Init>
     c28:	0e 94 b7 01 	call	0x36e	; 0x36e <EEEXT_Init>
     c2c:	0e 94 b4 06 	call	0xd68	; 0xd68 <MEMIF_Init>
     c30:	0e 94 88 07 	call	0xf10	; 0xf10 <NVM_Init>
     c34:	0e 94 54 00 	call	0xa8	; 0xa8 <App1_init>
     c38:	0e 94 bc 00 	call	0x178	; 0x178 <App2_init>
     c3c:	0e 94 22 05 	call	0xa44	; 0xa44 <lcd_init>
     c40:	0e 94 27 01 	call	0x24e	; 0x24e <BTN_Init>
     c44:	a1 2c       	mov	r10, r1
     c46:	b1 2c       	mov	r11, r1
     c48:	c1 2c       	mov	r12, r1
     c4a:	d1 2c       	mov	r13, r1
     c4c:	e1 2c       	mov	r14, r1
     c4e:	f1 2c       	mov	r15, r1
     c50:	02 e0       	ldi	r16, 0x02	; 2
     c52:	20 e0       	ldi	r18, 0x00	; 0
     c54:	30 e0       	ldi	r19, 0x00	; 0
     c56:	48 ec       	ldi	r20, 0xC8	; 200
     c58:	50 e0       	ldi	r21, 0x00	; 0
     c5a:	60 e0       	ldi	r22, 0x00	; 0
     c5c:	70 e0       	ldi	r23, 0x00	; 0
     c5e:	85 ea       	ldi	r24, 0xA5	; 165
     c60:	96 e0       	ldi	r25, 0x06	; 6
     c62:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xTaskGenericCreate>
     c66:	0e 94 c3 0b 	call	0x1786	; 0x1786 <vTaskStartScheduler>
     c6a:	ff cf       	rjmp	.-2      	; 0xc6a <main+0x4e>

00000c6c <Main_Main>:
	
}
void Main_Main(void)
{
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	1f 92       	push	r1
     c72:	cd b7       	in	r28, 0x3d	; 61
     c74:	de b7       	in	r29, 0x3e	; 62
	BtnStateType BtnState;
	switch(SystemState)
     c76:	80 91 a2 03 	lds	r24, 0x03A2	; 0x8003a2 <SystemState>
     c7a:	81 30       	cpi	r24, 0x01	; 1
     c7c:	99 f0       	breq	.+38     	; 0xca4 <Main_Main+0x38>
     c7e:	30 f0       	brcs	.+12     	; 0xc8c <Main_Main+0x20>
     c80:	82 30       	cpi	r24, 0x02	; 2
     c82:	89 f1       	breq	.+98     	; 0xce6 <Main_Main+0x7a>
     c84:	83 30       	cpi	r24, 0x03	; 3
     c86:	09 f4       	brne	.+2      	; 0xc8a <Main_Main+0x1e>
     c88:	48 c0       	rjmp	.+144    	; 0xd1a <Main_Main+0xae>
     c8a:	5b c0       	rjmp	.+182    	; 0xd42 <Main_Main+0xd6>
	{
		case STATE_IDLE:
		{
			lcd_clrScreen();
     c8c:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
			lcd_dispString("Reading NVM");
     c90:	8f eb       	ldi	r24, 0xBF	; 191
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
			NVM_ReadAll();
     c98:	0e 94 94 07 	call	0xf28	; 0xf28 <NVM_ReadAll>
			
			SystemState = STATE_READING;
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	80 93 a2 03 	sts	0x03A2, r24	; 0x8003a2 <SystemState>
		}
		break;
     ca2:	4f c0       	rjmp	.+158    	; 0xd42 <Main_Main+0xd6>
		case STATE_READING:
		{
			if(ReadAllDone == 1)
     ca4:	80 91 a1 03 	lds	r24, 0x03A1	; 0x8003a1 <ReadAllDone>
     ca8:	81 30       	cpi	r24, 0x01	; 1
     caa:	09 f0       	breq	.+2      	; 0xcae <Main_Main+0x42>
     cac:	4a c0       	rjmp	.+148    	; 0xd42 <Main_Main+0xd6>
			{
				
				ReadAllDone = 0;
     cae:	10 92 a1 03 	sts	0x03A1, r1	; 0x8003a1 <ReadAllDone>
				lcd_clrScreen();
     cb2:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
				lcd_gotoxy(0,0);
     cb6:	60 e0       	ldi	r22, 0x00	; 0
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				lcd_dispString("Waiting for");
     cbe:	8b ec       	ldi	r24, 0xCB	; 203
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				lcd_gotoxy(0,1);
     cc6:	61 e0       	ldi	r22, 0x01	; 1
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				lcd_dispString("first press");
     cce:	87 ed       	ldi	r24, 0xD7	; 215
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				lcd_gotoxy(0,0);
     cd6:	60 e0       	ldi	r22, 0x00	; 0
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				SystemState = STATE_RUNNING;
     cde:	82 e0       	ldi	r24, 0x02	; 2
     ce0:	80 93 a2 03 	sts	0x03A2, r24	; 0x8003a2 <SystemState>
     ce4:	2e c0       	rjmp	.+92     	; 0xd42 <Main_Main+0xd6>
			}
		}
		break;
		case STATE_RUNNING:
		{
			BTN_Manager();
     ce6:	0e 94 35 01 	call	0x26a	; 0x26a <BTN_Manager>
			App1_main();
     cea:	0e 94 63 00 	call	0xc6	; 0xc6 <App1_main>
			App2_main();
     cee:	0e 94 cb 00 	call	0x196	; 0x196 <App2_main>
			BTN_GetState(&BtnState,2);
     cf2:	62 e0       	ldi	r22, 0x02	; 2
     cf4:	ce 01       	movw	r24, r28
     cf6:	01 96       	adiw	r24, 0x01	; 1
     cf8:	0e 94 2d 01 	call	0x25a	; 0x25a <BTN_GetState>
			if(BtnState == PRESSED)
     cfc:	89 81       	ldd	r24, Y+1	; 0x01
     cfe:	81 30       	cpi	r24, 0x01	; 1
     d00:	01 f5       	brne	.+64     	; 0xd42 <Main_Main+0xd6>
			{
				lcd_clrScreen();
     d02:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
				lcd_dispString("Writing NVM");
     d06:	83 ee       	ldi	r24, 0xE3	; 227
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				NVM_WriteAll();
     d0e:	0e 94 a7 07 	call	0xf4e	; 0xf4e <NVM_WriteAll>
				SystemState = STATE_WRITING;
     d12:	83 e0       	ldi	r24, 0x03	; 3
     d14:	80 93 a2 03 	sts	0x03A2, r24	; 0x8003a2 <SystemState>
     d18:	14 c0       	rjmp	.+40     	; 0xd42 <Main_Main+0xd6>
			
		}
		break;
		case STATE_WRITING:
		{
			if(WriteAllDone == 1)
     d1a:	80 91 a0 03 	lds	r24, 0x03A0	; 0x8003a0 <WriteAllDone>
     d1e:	81 30       	cpi	r24, 0x01	; 1
     d20:	81 f4       	brne	.+32     	; 0xd42 <Main_Main+0xd6>
			{
				WriteAllDone = 0;
     d22:	10 92 a0 03 	sts	0x03A0, r1	; 0x8003a0 <WriteAllDone>
				lcd_clrScreen();
     d26:	0e 94 59 05 	call	0xab2	; 0xab2 <lcd_clrScreen>
				lcd_dispString("Write all done");
     d2a:	8f ee       	ldi	r24, 0xEF	; 239
     d2c:	90 e0       	ldi	r25, 0x00	; 0
     d2e:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				lcd_gotoxy(0,1);
     d32:	61 e0       	ldi	r22, 0x01	; 1
     d34:	80 e0       	ldi	r24, 0x00	; 0
     d36:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_gotoxy>
				lcd_dispString("you can power off");
     d3a:	8e ef       	ldi	r24, 0xFE	; 254
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_dispString>
				
			}
		}
		break;
	}
     d42:	0f 90       	pop	r0
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	08 95       	ret

00000d4a <task1_code>:
void task1_code(void *p)
{

	while(1)
	{
		vTaskDelay(50);
     d4a:	82 e3       	ldi	r24, 0x32	; 50
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	0e 94 3e 0d 	call	0x1a7c	; 0x1a7c <vTaskDelay>
		
		EEINT_Main();
     d52:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <EEINT_Main>
		EEEXT_Main();
     d56:	0e 94 09 02 	call	0x412	; 0x412 <EEEXT_Main>
		MEMIF_Main();
     d5a:	0e 94 14 07 	call	0xe28	; 0xe28 <MEMIF_Main>
		NVM_Main();
     d5e:	0e 94 ed 07 	call	0xfda	; 0xfda <NVM_Main>
		Main_Main();
     d62:	0e 94 36 06 	call	0xc6c	; 0xc6c <Main_Main>
     d66:	f1 cf       	rjmp	.-30     	; 0xd4a <task1_code>

00000d68 <MEMIF_Init>:
{
    #if (ENABLE == TEST)
    printf("Function: MEMIF_Init start \n");
    #endif
    /*initiate globla variables*/
    gu8_WriteBlockFlag = CLEAR_BLOCK_FLAG;
     d68:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <gu8_WriteBlockFlag>
    gu8_READ_BLOCK_FLAG = CLEAR_BLOCK_FLAG;
     d6c:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <gu8_READ_BLOCK_FLAG>
    gu8_MainFuncStatus = IDLE_STATUS;
     d70:	85 e0       	ldi	r24, 0x05	; 5
     d72:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
    gu8_DataPtr = NULL;
     d76:	10 92 a6 03 	sts	0x03A6, r1	; 0x8003a6 <gu8_DataPtr+0x1>
     d7a:	10 92 a5 03 	sts	0x03A5, r1	; 0x8003a5 <gu8_DataPtr>
     d7e:	08 95       	ret

00000d80 <MEMIF_ReqWriteBlock>:
    #endif
}


MEMIF_CheckType MEMIF_ReqWriteBlock(unsigned char BlockId, unsigned char* DataPtr)
{
     d80:	98 2f       	mov	r25, r24
    MEMIF_CheckType au8_Return = MEMIF_OK; /*consider the return ok as initial value*/
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	61 15       	cp	r22, r1
     d86:	71 05       	cpc	r23, r1
     d88:	09 f0       	breq	.+2      	; 0xd8c <MEMIF_ReqWriteBlock+0xc>
     d8a:	80 e0       	ldi	r24, 0x00	; 0
    printf("Searching about Block ID ... \n");
    #endif
    
    for(au8_Counter = COUNTER_INITIAL_VALUE; au8_Counter < MEMIF_NUM_OF_BLOCKS; au8_Counter++)
    {
        au8_LogicalBlockId = MEMIF_ConfigParam.BlockConfigPtr[au8_Counter].LogicalBlockId;
     d8c:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <MEMIF_ConfigParam>
     d90:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <MEMIF_ConfigParam+0x1>
        /*ensure that given block id exist*/
        if (BlockId == au8_LogicalBlockId)
     d94:	20 81       	ld	r18, Z
     d96:	92 17       	cp	r25, r18
     d98:	29 f0       	breq	.+10     	; 0xda4 <MEMIF_ReqWriteBlock+0x24>
     d9a:	24 81       	ldd	r18, Z+4	; 0x04
     d9c:	29 13       	cpse	r18, r25
     d9e:	16 c0       	rjmp	.+44     	; 0xdcc <MEMIF_ReqWriteBlock+0x4c>
    
    #if (ENABLE == TEST)
    printf("Searching about Block ID ... \n");
    #endif
    
    for(au8_Counter = COUNTER_INITIAL_VALUE; au8_Counter < MEMIF_NUM_OF_BLOCKS; au8_Counter++)
     da0:	21 e0       	ldi	r18, 0x01	; 1
     da2:	01 c0       	rjmp	.+2      	; 0xda6 <MEMIF_ReqWriteBlock+0x26>
    {
        au8_LogicalBlockId = MEMIF_ConfigParam.BlockConfigPtr[au8_Counter].LogicalBlockId;
        /*ensure that given block id exist*/
        if (BlockId == au8_LogicalBlockId)
     da4:	20 e0       	ldi	r18, 0x00	; 0
            printf("Block Id doesn't exist \n");
            #endif
        }
    }
    /*if the parameter is valid*/
    if (MEMIF_OK == au8_Return)
     da6:	81 11       	cpse	r24, r1
     da8:	14 c0       	rjmp	.+40     	; 0xdd2 <MEMIF_ReqWriteBlock+0x52>
    {
        #if (ENABLE == TEST)
        printf("Function: MEMIF_ReqWriteBlock Parameters are valid \n");
        #endif
        /*ensure that the module is available*/
        if (IDLE_STATUS != gu8_MainFuncStatus)
     daa:	90 91 a3 03 	lds	r25, 0x03A3	; 0x8003a3 <gu8_MainFuncStatus>
     dae:	95 30       	cpi	r25, 0x05	; 5
     db0:	79 f4       	brne	.+30     	; 0xdd0 <MEMIF_ReqWriteBlock+0x50>
        {
            #if (ENABLE == TEST)
            printf("Function: MEMIF_ReqWriteBlock storing parameters...  \n");
            #endif
            /*stores the parameter in global variable to use it in main function*/
            gu8_DataPtr = DataPtr;
     db2:	70 93 a6 03 	sts	0x03A6, r23	; 0x8003a6 <gu8_DataPtr+0x1>
     db6:	60 93 a5 03 	sts	0x03A5, r22	; 0x8003a5 <gu8_DataPtr>
            gu8_BlockNum = au8_Counter;
     dba:	20 93 a4 03 	sts	0x03A4, r18	; 0x8003a4 <gu8_BlockNum>
            gu8_WriteBlockFlag = SET_BLOCK_FLAG; /*set write block flag*/
     dbe:	91 e0       	ldi	r25, 0x01	; 1
     dc0:	90 93 a8 03 	sts	0x03A8, r25	; 0x8003a8 <gu8_WriteBlockFlag>
            gu8_MainFuncStatus = LOGIC_STATUS; /*change the main function status to logic status*/
     dc4:	96 e0       	ldi	r25, 0x06	; 6
     dc6:	90 93 a3 03 	sts	0x03A3, r25	; 0x8003a3 <gu8_MainFuncStatus>
     dca:	08 95       	ret
            #endif
        }
        
        if ( au8_Counter == (MEMIF_NUM_OF_BLOCKS - 1u) )
        {
            au8_Return = MEMIF_NOK;
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	08 95       	ret
        printf("Function: MEMIF_ReqWriteBlock Parameters are valid \n");
        #endif
        /*ensure that the module is available*/
        if (IDLE_STATUS != gu8_MainFuncStatus)
        {
            au8_Return = MEMIF_BUSY;
     dd0:	82 e0       	ldi	r24, 0x02	; 2
    
    #if (ENABLE == TEST)
    printf("Function: MEMIF_ReqWriteBlock returns \n");
    #endif
    return au8_Return;
}
     dd2:	08 95       	ret

00000dd4 <MEMIF_ReqReadBlock>:

MEMIF_CheckType MEMIF_ReqReadBlock(unsigned char BlockId, unsigned char* DataPtr)
{
     dd4:	98 2f       	mov	r25, r24
    MEMIF_CheckType au8_Return = MEMIF_OK;/*consider the return ok as initial value*/
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	61 15       	cp	r22, r1
     dda:	71 05       	cpc	r23, r1
     ddc:	09 f0       	breq	.+2      	; 0xde0 <MEMIF_ReqReadBlock+0xc>
     dde:	80 e0       	ldi	r24, 0x00	; 0
     printf("Searching about Block ID ... \n");
     #endif    
    
    for(au8_Counter = COUNTER_INITIAL_VALUE; au8_Counter < MEMIF_NUM_OF_BLOCKS; au8_Counter++)
    {
        au8_LogicalBlockId = MEMIF_ConfigParam.BlockConfigPtr[au8_Counter].LogicalBlockId;
     de0:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <MEMIF_ConfigParam>
     de4:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <MEMIF_ConfigParam+0x1>
        /*ensure that given block id exist*/
        if (BlockId == au8_LogicalBlockId)
     de8:	20 81       	ld	r18, Z
     dea:	92 17       	cp	r25, r18
     dec:	29 f0       	breq	.+10     	; 0xdf8 <MEMIF_ReqReadBlock+0x24>
     dee:	24 81       	ldd	r18, Z+4	; 0x04
     df0:	29 13       	cpse	r18, r25
     df2:	16 c0       	rjmp	.+44     	; 0xe20 <MEMIF_ReqReadBlock+0x4c>
            
     #if (ENABLE == TEST)
     printf("Searching about Block ID ... \n");
     #endif    
    
    for(au8_Counter = COUNTER_INITIAL_VALUE; au8_Counter < MEMIF_NUM_OF_BLOCKS; au8_Counter++)
     df4:	21 e0       	ldi	r18, 0x01	; 1
     df6:	01 c0       	rjmp	.+2      	; 0xdfa <MEMIF_ReqReadBlock+0x26>
    {
        au8_LogicalBlockId = MEMIF_ConfigParam.BlockConfigPtr[au8_Counter].LogicalBlockId;
        /*ensure that given block id exist*/
        if (BlockId == au8_LogicalBlockId)
     df8:	20 e0       	ldi	r18, 0x00	; 0
            printf("Block Id doesn't exist \n");
            #endif
        }
    }
    /*if the parameter is valid*/
    if (MEMIF_OK == au8_Return)
     dfa:	81 11       	cpse	r24, r1
     dfc:	14 c0       	rjmp	.+40     	; 0xe26 <MEMIF_ReqReadBlock+0x52>
    {
         #if (ENABLE == TEST)
         printf("Function: MEMIF_ReqWriteBlock Parameters are valid \n");
         #endif
        /*ensure that the module is available*/
        if (IDLE_STATUS != gu8_MainFuncStatus)
     dfe:	90 91 a3 03 	lds	r25, 0x03A3	; 0x8003a3 <gu8_MainFuncStatus>
     e02:	95 30       	cpi	r25, 0x05	; 5
     e04:	79 f4       	brne	.+30     	; 0xe24 <MEMIF_ReqReadBlock+0x50>
        {
            #if (ENABLE == TEST)
            printf("Function: MEMIF_ReqWriteBlock storing parameters...  \n");
            #endif
            /*stores the parameter in global variable to use it in main function*/
            gu8_DataPtr = DataPtr;
     e06:	70 93 a6 03 	sts	0x03A6, r23	; 0x8003a6 <gu8_DataPtr+0x1>
     e0a:	60 93 a5 03 	sts	0x03A5, r22	; 0x8003a5 <gu8_DataPtr>
            gu8_BlockNum = au8_Counter;
     e0e:	20 93 a4 03 	sts	0x03A4, r18	; 0x8003a4 <gu8_BlockNum>
            gu8_READ_BLOCK_FLAG = SET_BLOCK_FLAG; /*set read block flag*/
     e12:	91 e0       	ldi	r25, 0x01	; 1
     e14:	90 93 a7 03 	sts	0x03A7, r25	; 0x8003a7 <gu8_READ_BLOCK_FLAG>
            gu8_MainFuncStatus = LOGIC_STATUS; /*change the main function status to logic status*/
     e18:	96 e0       	ldi	r25, 0x06	; 6
     e1a:	90 93 a3 03 	sts	0x03A3, r25	; 0x8003a3 <gu8_MainFuncStatus>
     e1e:	08 95       	ret
             #endif
        }
        
        if ( au8_Counter == (MEMIF_NUM_OF_BLOCKS - 1u) )
        {
            au8_Return = MEMIF_NOK;
     e20:	81 e0       	ldi	r24, 0x01	; 1
     e22:	08 95       	ret
         printf("Function: MEMIF_ReqWriteBlock Parameters are valid \n");
         #endif
        /*ensure that the module is available*/
        if (IDLE_STATUS != gu8_MainFuncStatus)
        {
            au8_Return = MEMIF_BUSY;
     e24:	82 e0       	ldi	r24, 0x02	; 2
    }
     #if (ENABLE == TEST)
     printf("Function: MEMIF_ReqWriteBlock returns \n");
     #endif
    return au8_Return;
}
     e26:	08 95       	ret

00000e28 <MEMIF_Main>:
    uint8_t au8_StartAddress,
            au8_Length,
            au8_StorageType,
            au8_FuncReturn = EEINT_NOK; /*consider the return of called function is ok as initial value*/
            
    switch (gu8_MainFuncStatus)
     e28:	80 91 a3 03 	lds	r24, 0x03A3	; 0x8003a3 <gu8_MainFuncStatus>
     e2c:	86 30       	cpi	r24, 0x06	; 6
     e2e:	09 f0       	breq	.+2      	; 0xe32 <MEMIF_Main+0xa>
     e30:	42 c0       	rjmp	.+132    	; 0xeb6 <MEMIF_Main+0x8e>
        #endif
        /*** get data from config structure ***/
        #if (ENABLE == TEST)
        printf("Function: MEMIF_Main storing Parameters ... \n");
        #endif
        au8_StartAddress = MEMIF_ConfigParam.BlockConfigPtr[gu8_BlockNum].BlockPhyAddress;
     e32:	80 91 a4 03 	lds	r24, 0x03A4	; 0x8003a4 <gu8_BlockNum>
     e36:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <MEMIF_ConfigParam>
     e3a:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <MEMIF_ConfigParam+0x1>
     e3e:	94 e0       	ldi	r25, 0x04	; 4
     e40:	89 9f       	mul	r24, r25
     e42:	e0 0d       	add	r30, r0
     e44:	f1 1d       	adc	r31, r1
     e46:	11 24       	eor	r1, r1
     e48:	83 81       	ldd	r24, Z+3	; 0x03
        
        au8_Length = MEMIF_ConfigParam.BlockConfigPtr[gu8_BlockNum].BlockLength;
     e4a:	41 81       	ldd	r20, Z+1	; 0x01
        
        au8_StorageType = MEMIF_ConfigParam.BlockConfigPtr[gu8_BlockNum].BlockStoragePlace;
     e4c:	22 81       	ldd	r18, Z+2	; 0x02
        /*check if the desired operation is write operation*/
        if (SET_BLOCK_FLAG == gu8_WriteBlockFlag) 
     e4e:	90 91 a8 03 	lds	r25, 0x03A8	; 0x8003a8 <gu8_WriteBlockFlag>
     e52:	91 30       	cpi	r25, 0x01	; 1
     e54:	91 f4       	brne	.+36     	; 0xe7a <MEMIF_Main+0x52>
        {
            #if (ENABLE == TEST)
            printf("Function: MEMIF_Main in IDLE Status, Write mode \n");
            #endif
            /*check if the operation occurs on external or internal EEPROM*/
            if (INTERNAL_MEM == au8_StorageType)
     e56:	21 11       	cpse	r18, r1
     e58:	07 c0       	rjmp	.+14     	; 0xe68 <MEMIF_Main+0x40>
            {
                #if (ENABLE == TEST)
                printf("Function: MEMIF_Main writing in internal EEPROM ... \n");
                #endif
                /*write the desired data on internal EEPROM*/
                au8_FuncReturn = EEINT_ReqWrite(au8_StartAddress,gu8_DataPtr, au8_Length);
     e5a:	60 91 a5 03 	lds	r22, 0x03A5	; 0x8003a5 <gu8_DataPtr>
     e5e:	70 91 a6 03 	lds	r23, 0x03A6	; 0x8003a6 <gu8_DataPtr+0x1>
     e62:	0e 94 aa 02 	call	0x554	; 0x554 <EEINT_ReqWrite>
     e66:	1e c0       	rjmp	.+60     	; 0xea4 <MEMIF_Main+0x7c>
            } 
            
            else if (EXTERNAL_MEM == au8_StorageType)
     e68:	21 30       	cpi	r18, 0x01	; 1
     e6a:	11 f5       	brne	.+68     	; 0xeb0 <MEMIF_Main+0x88>
            {
                #if (ENABLE == TEST)
                printf("Function: MEMIF_Main writing in external EEPROM ... \n");
                #endif
                /*write the desired data on external EEPROM*/
                au8_FuncReturn = EEEXT_ReqWrite(au8_StartAddress, gu8_DataPtr, au8_Length);
     e6c:	60 91 a5 03 	lds	r22, 0x03A5	; 0x8003a5 <gu8_DataPtr>
     e70:	70 91 a6 03 	lds	r23, 0x03A6	; 0x8003a6 <gu8_DataPtr+0x1>
     e74:	0e 94 c7 01 	call	0x38e	; 0x38e <EEEXT_ReqWrite>
     e78:	15 c0       	rjmp	.+42     	; 0xea4 <MEMIF_Main+0x7c>
                printf("Function: MEMIF_Main Error in storage type !!! \n");
                #endif
            }
        } 
        /*check if the desired operation is read operation*/
        else if (SET_BLOCK_FLAG == gu8_READ_BLOCK_FLAG)
     e7a:	90 91 a7 03 	lds	r25, 0x03A7	; 0x8003a7 <gu8_READ_BLOCK_FLAG>
     e7e:	91 30       	cpi	r25, 0x01	; 1
     e80:	b9 f4       	brne	.+46     	; 0xeb0 <MEMIF_Main+0x88>
        {
            #if (ENABLE == TEST)
            printf("Function: MEMIF_Main in IDLE Status, Read mode \n");
            #endif
            /*check if the operation occurs on external or internal EEPROM*/
            if (INTERNAL_MEM == au8_StorageType)
     e82:	21 11       	cpse	r18, r1
     e84:	07 c0       	rjmp	.+14     	; 0xe94 <MEMIF_Main+0x6c>
            {
                #if (ENABLE == TEST)
                printf("Function: MEMIF_Main Reading from internal EEPROM \n");
                #endif
                /*read the desired data from internal EEPROM*/
                au8_FuncReturn = EEINT_ReqRead(au8_StartAddress, gu8_DataPtr, au8_Length);
     e86:	60 91 a5 03 	lds	r22, 0x03A5	; 0x8003a5 <gu8_DataPtr>
     e8a:	70 91 a6 03 	lds	r23, 0x03A6	; 0x8003a6 <gu8_DataPtr+0x1>
     e8e:	0e 94 ca 02 	call	0x594	; 0x594 <EEINT_ReqRead>
     e92:	08 c0       	rjmp	.+16     	; 0xea4 <MEMIF_Main+0x7c>
				
            }
            else if (EXTERNAL_MEM == au8_StorageType)
     e94:	21 30       	cpi	r18, 0x01	; 1
     e96:	61 f4       	brne	.+24     	; 0xeb0 <MEMIF_Main+0x88>
            {
                #if (ENABLE == TEST)
                printf("Function: MEMIF_Main Reading from external EEPROM \n");
                #endif
                /*read the desired data from external EEPROM*/
                au8_FuncReturn = EEEXT_ReqRead(au8_StartAddress, gu8_DataPtr, au8_Length);
     e98:	60 91 a5 03 	lds	r22, 0x03A5	; 0x8003a5 <gu8_DataPtr>
     e9c:	70 91 a6 03 	lds	r23, 0x03A6	; 0x8003a6 <gu8_DataPtr+0x1>
     ea0:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <EEEXT_ReqRead>
            #if (ENABLE == TEST)
            printf("Function: MEMIF_Main Error in R/W operation mode !!! \n");
            #endif
        }
        
        if (  (EEINT_OK == au8_FuncReturn) || (EEEXT_OK == au8_FuncReturn) )
     ea4:	81 11       	cpse	r24, r1
     ea6:	04 c0       	rjmp	.+8      	; 0xeb0 <MEMIF_Main+0x88>
        {
            gu8_MainFuncStatus = WAIT_STATUS; /*move the status if the called function retrun ok*/
     ea8:	87 e0       	ldi	r24, 0x07	; 7
     eaa:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
     eae:	08 95       	ret
            printf("Function: MEMIF_Main R/W operation Done \n");
            #endif
        }
        else
        {
            gu8_MainFuncStatus = LOGIC_STATUS;
     eb0:	86 e0       	ldi	r24, 0x06	; 6
     eb2:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
     eb6:	08 95       	ret

00000eb8 <MEMIF_IntEepromWriteCbk>:
{
    #if (ENABLE == TEST)
    printf("Function: MEMIF_IntEepromWriteCbk start \n");
    #endif
    /*reset the flags and notify the MEMIF*/
    gu8_WriteBlockFlag = CLEAR_BLOCK_FLAG;
     eb8:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <gu8_WriteBlockFlag>
    
    gu8_MainFuncStatus = IDLE_STATUS;
     ebc:	85 e0       	ldi	r24, 0x05	; 5
     ebe:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
    
    #if (ENABLE == TEST)
    printf("Function: BlockWriteDoneNotif call \n");
    #endif
    MEMIF_ConfigParam.BlockWriteDoneNotif();
     ec2:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <MEMIF_ConfigParam+0x2>
     ec6:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <MEMIF_ConfigParam+0x3>
     eca:	09 95       	icall
     ecc:	08 95       	ret

00000ece <MEMIF_IntEepromReadCbk>:
{
    #if (ENABLE == TEST)
    printf("Function: MEMIF_IntEepromReadCbk start \n");
    #endif
    /*reset the flags and notify the MEMIF*/
    gu8_READ_BLOCK_FLAG = CLEAR_BLOCK_FLAG;
     ece:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <gu8_READ_BLOCK_FLAG>
    
    gu8_MainFuncStatus = IDLE_STATUS;
     ed2:	85 e0       	ldi	r24, 0x05	; 5
     ed4:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
    #if (ENABLE == TEST)
    printf("Function: BlockReadDoneNotif call \n");
    #endif
    MEMIF_ConfigParam.BlockReadDoneNotif();
     ed8:	e0 91 14 01 	lds	r30, 0x0114	; 0x800114 <MEMIF_ConfigParam+0x4>
     edc:	f0 91 15 01 	lds	r31, 0x0115	; 0x800115 <MEMIF_ConfigParam+0x5>
     ee0:	09 95       	icall
     ee2:	08 95       	ret

00000ee4 <MEMIF_ExtEepromWriteCbk>:
{
    #if (ENABLE == TEST)
    printf("Function: MEMIF_ExtEepromWriteCbk start \n");
    #endif
    /*reset the flags and notify the MEMIF*/
    gu8_WriteBlockFlag = CLEAR_BLOCK_FLAG;
     ee4:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <gu8_WriteBlockFlag>
    
    gu8_MainFuncStatus = IDLE_STATUS;
     ee8:	85 e0       	ldi	r24, 0x05	; 5
     eea:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
    #if (ENABLE == TEST)
    printf("Function: BlockWriteDoneNotif call \n");
    #endif
    MEMIF_ConfigParam.BlockWriteDoneNotif();
     eee:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <MEMIF_ConfigParam+0x2>
     ef2:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <MEMIF_ConfigParam+0x3>
     ef6:	09 95       	icall
     ef8:	08 95       	ret

00000efa <MEMIF_ExtEepromReadCbk>:
{
    #if (ENABLE == TEST)
    printf("Function: MEMIF_ExtEepromReadCbk start \n");
    #endif
    /*reset the flags and notify the MEMIF*/
    gu8_READ_BLOCK_FLAG = CLEAR_BLOCK_FLAG;
     efa:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <gu8_READ_BLOCK_FLAG>
    
    gu8_MainFuncStatus = IDLE_STATUS;
     efe:	85 e0       	ldi	r24, 0x05	; 5
     f00:	80 93 a3 03 	sts	0x03A3, r24	; 0x8003a3 <gu8_MainFuncStatus>
    #if (ENABLE == TEST)
    printf("Function: BlockReadDoneNotif call \n");
    #endif
    MEMIF_ConfigParam.BlockReadDoneNotif();
     f04:	e0 91 14 01 	lds	r30, 0x0114	; 0x800114 <MEMIF_ConfigParam+0x4>
     f08:	f0 91 15 01 	lds	r31, 0x0115	; 0x800115 <MEMIF_ConfigParam+0x5>
     f0c:	09 95       	icall
     f0e:	08 95       	ret

00000f10 <NVM_Init>:
static  volatile uint8_t gu8_ReadDone;


void NVM_Init(void)
{
	if(gu8_NVM_INIT_Flag==INITIALIZED)
     f10:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <gu8_NVM_INIT_Flag>
     f14:	81 30       	cpi	r24, 0x01	; 1
     f16:	39 f0       	breq	.+14     	; 0xf26 <NVM_Init+0x16>
	{

	}
	else
	{
		gu8_NVM_INIT_Flag=INITIALIZED;
     f18:	81 e0       	ldi	r24, 0x01	; 1
     f1a:	80 93 b4 03 	sts	0x03B4, r24	; 0x8003b4 <gu8_NVM_INIT_Flag>
		gu8_NVM_SM=IDLE_STATE;
     f1e:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <gu8_NVM_SM>
		gu8_NVMbusy_flag=FREE;
     f22:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
     f26:	08 95       	ret

00000f28 <NVM_ReadAll>:


NVM_CheckType NVM_ReadAll(void)
{
	NVM_CheckType Error=NVM_OK;
	if(gu8_NVM_INIT_Flag==UN_INITIALIZED)
     f28:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <gu8_NVM_INIT_Flag>
     f2c:	88 23       	and	r24, r24
     f2e:	59 f0       	breq	.+22     	; 0xf46 <NVM_ReadAll+0x1e>
	{
		Error=NVM_NOK;
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
     f30:	80 91 b3 03 	lds	r24, 0x03B3	; 0x8003b3 <gu8_NVMbusy_flag>
     f34:	81 30       	cpi	r24, 0x01	; 1
     f36:	49 f0       	breq	.+18     	; 0xf4a <NVM_ReadAll+0x22>
			Error=NVM_BUSY;
		}
		else
		{
		
			gu8_NVM_SM=READ_ALL_STATE;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
			gu8_NVMbusy_flag=BUSY;
     f3e:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <gu8_NVMbusy_flag>
}


NVM_CheckType NVM_ReadAll(void)
{
	NVM_CheckType Error=NVM_OK;
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	08 95       	ret
	if(gu8_NVM_INIT_Flag==UN_INITIALIZED)
	{
		Error=NVM_NOK;
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	08 95       	ret
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
		{
			Error=NVM_BUSY;
     f4a:	82 e0       	ldi	r24, 0x02	; 2
		}

	}

	return Error;
}
     f4c:	08 95       	ret

00000f4e <NVM_WriteAll>:


NVM_CheckType NVM_WriteAll(void)
{
	NVM_CheckType Error=NVM_OK;
	if(gu8_NVM_INIT_Flag==UN_INITIALIZED)
     f4e:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <gu8_NVM_INIT_Flag>
     f52:	88 23       	and	r24, r24
     f54:	61 f0       	breq	.+24     	; 0xf6e <NVM_WriteAll+0x20>
	{
		Error=NVM_NOK;
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
     f56:	80 91 b3 03 	lds	r24, 0x03B3	; 0x8003b3 <gu8_NVMbusy_flag>
     f5a:	81 30       	cpi	r24, 0x01	; 1
     f5c:	51 f0       	breq	.+20     	; 0xf72 <NVM_WriteAll+0x24>
		{
			Error=NVM_BUSY;
		}
		else
		{
			gu8_NVM_SM=WRITE_ALL_STATE;
     f5e:	82 e0       	ldi	r24, 0x02	; 2
     f60:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
			gu8_NVMbusy_flag=BUSY;
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <gu8_NVMbusy_flag>
}


NVM_CheckType NVM_WriteAll(void)
{
	NVM_CheckType Error=NVM_OK;
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	08 95       	ret
	if(gu8_NVM_INIT_Flag==UN_INITIALIZED)
	{
		Error=NVM_NOK;
     f6e:	81 e0       	ldi	r24, 0x01	; 1
     f70:	08 95       	ret
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
		{
			Error=NVM_BUSY;
     f72:	82 e0       	ldi	r24, 0x02	; 2
		}

	}

	return Error;
}
     f74:	08 95       	ret

00000f76 <NVM_ReadBlock>:


NVM_CheckType NVM_ReadBlock(unsigned char BlockId, unsigned char* DataPtr)
{
	NVM_CheckType Error=NVM_OK;
	if(NULL==DataPtr)
     f76:	61 15       	cp	r22, r1
     f78:	71 05       	cpc	r23, r1
     f7a:	91 f0       	breq	.+36     	; 0xfa0 <NVM_ReadBlock+0x2a>
	{
		Error=NVM_NOK;
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
     f7c:	90 91 b3 03 	lds	r25, 0x03B3	; 0x8003b3 <gu8_NVMbusy_flag>
     f80:	91 30       	cpi	r25, 0x01	; 1
     f82:	81 f0       	breq	.+32     	; 0xfa4 <NVM_ReadBlock+0x2e>
		{
			Error=NVM_BUSY;
		}
		else
		{
			gu8_Read_ID=BlockId;
     f84:	80 93 b2 03 	sts	0x03B2, r24	; 0x8003b2 <gu8_Read_ID>
			gu8ptr_ReadData=DataPtr;
     f88:	70 93 b1 03 	sts	0x03B1, r23	; 0x8003b1 <gu8ptr_ReadData+0x1>
     f8c:	60 93 b0 03 	sts	0x03B0, r22	; 0x8003b0 <gu8ptr_ReadData>
			gu8_NVMbusy_flag=BUSY;
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <gu8_NVMbusy_flag>
			gu8_NVM_SM=READ_BLOCK_STATE;
     f96:	85 e0       	ldi	r24, 0x05	; 5
     f98:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
}


NVM_CheckType NVM_ReadBlock(unsigned char BlockId, unsigned char* DataPtr)
{
	NVM_CheckType Error=NVM_OK;
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	08 95       	ret
	if(NULL==DataPtr)
	{
		Error=NVM_NOK;
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	08 95       	ret
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
		{
			Error=NVM_BUSY;
     fa4:	82 e0       	ldi	r24, 0x02	; 2
		}

	}

	return Error;
}
     fa6:	08 95       	ret

00000fa8 <NVM_WriteBlock>:
NVM_CheckType NVM_WriteBlock(uint8_t BlockId, uint8_t* DataPtr)
{
	NVM_CheckType Error=NVM_OK;
	if(NULL==DataPtr)
     fa8:	61 15       	cp	r22, r1
     faa:	71 05       	cpc	r23, r1
     fac:	91 f0       	breq	.+36     	; 0xfd2 <NVM_WriteBlock+0x2a>
	{
		Error=NVM_NOK;
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
     fae:	90 91 b3 03 	lds	r25, 0x03B3	; 0x8003b3 <gu8_NVMbusy_flag>
     fb2:	91 30       	cpi	r25, 0x01	; 1
     fb4:	81 f0       	breq	.+32     	; 0xfd6 <NVM_WriteBlock+0x2e>
		{
			Error=NVM_BUSY;
		}
		else
		{
			gu8_Write_ID=BlockId;
     fb6:	80 93 af 03 	sts	0x03AF, r24	; 0x8003af <gu8_Write_ID>
			gu8ptr_WriteData=DataPtr;
     fba:	70 93 ae 03 	sts	0x03AE, r23	; 0x8003ae <gu8ptr_WriteData+0x1>
     fbe:	60 93 ad 03 	sts	0x03AD, r22	; 0x8003ad <gu8ptr_WriteData>
			gu8_NVMbusy_flag=BUSY;
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <gu8_NVMbusy_flag>
			gu8_NVM_SM=WRITE_BLOCK_STATE;
     fc8:	86 e0       	ldi	r24, 0x06	; 6
     fca:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>

	return Error;
}
NVM_CheckType NVM_WriteBlock(uint8_t BlockId, uint8_t* DataPtr)
{
	NVM_CheckType Error=NVM_OK;
     fce:	80 e0       	ldi	r24, 0x00	; 0
     fd0:	08 95       	ret
	if(NULL==DataPtr)
	{
		Error=NVM_NOK;
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	08 95       	ret
	}
	else
	{
		if(gu8_NVMbusy_flag==BUSY)
		{
			Error=NVM_BUSY;
     fd6:	82 e0       	ldi	r24, 0x02	; 2
			gu8_NVM_SM=WRITE_BLOCK_STATE;
		}

	}
	return Error;
}
     fd8:	08 95       	ret

00000fda <NVM_Main>:


void NVM_Main(void)
{
     fda:	cf 93       	push	r28
     fdc:	df 93       	push	r29
	static uint8_t au8_ID_count=0;
	static uint8_t au8_LEN_Count=0;
	switch(gu8_NVM_SM)
     fde:	e0 91 b5 03 	lds	r30, 0x03B5	; 0x8003b5 <gu8_NVM_SM>
     fe2:	8e 2f       	mov	r24, r30
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	8b 30       	cpi	r24, 0x0B	; 11
     fe8:	91 05       	cpc	r25, r1
     fea:	08 f0       	brcs	.+2      	; 0xfee <NVM_Main+0x14>
     fec:	31 c1       	rjmp	.+610    	; 0x1250 <NVM_Main+0x276>
     fee:	fc 01       	movw	r30, r24
     ff0:	e6 5d       	subi	r30, 0xD6	; 214
     ff2:	ff 4f       	sbci	r31, 0xFF	; 255
     ff4:	0c 94 30 0e 	jmp	0x1c60	; 0x1c60 <__tablejump2__>
	{
		case IDLE_STATE:
		gu8_NVMbusy_flag=FREE;
     ff8:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
		au8_LEN_Count=0;
     ffc:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <au8_LEN_Count.1722>
		au8_ID_count=0;
    1000:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
		break;
    1004:	25 c1       	rjmp	.+586    	; 0x1250 <NVM_Main+0x276>
		case WRITE_ALL_STATE:
		if(au8_ID_count==NVM_NUM_OF_BLOCKS)
    1006:	e0 91 a9 03 	lds	r30, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    100a:	e2 30       	cpi	r30, 0x02	; 2
    100c:	21 f4       	brne	.+8      	; 0x1016 <NVM_Main+0x3c>
		{
			gu8_NVM_SM=WRITE_ALL_DONE_STATE;
    100e:	84 e0       	ldi	r24, 0x04	; 4
    1010:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    1014:	1d c1       	rjmp	.+570    	; 0x1250 <NVM_Main+0x276>
		}
		else
		{
			MEMIF_ReqWriteBlock(NVM_BlocConfig[au8_ID_count].BlockId,NVM_BlocConfig[au8_ID_count].BlockRamAddress);
    1016:	f0 e0       	ldi	r31, 0x00	; 0
    1018:	ee 0f       	add	r30, r30
    101a:	ff 1f       	adc	r31, r31
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	eb 59       	subi	r30, 0x9B	; 155
    1026:	ff 4f       	sbci	r31, 0xFF	; 255
    1028:	62 81       	ldd	r22, Z+2	; 0x02
    102a:	73 81       	ldd	r23, Z+3	; 0x03
    102c:	80 81       	ld	r24, Z
    102e:	0e 94 c0 06 	call	0xd80	; 0xd80 <MEMIF_ReqWriteBlock>
			au8_ID_count++;
    1032:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    1036:	8f 5f       	subi	r24, 0xFF	; 255
    1038:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <au8_ID_count.1721>
			gu8_NVM_SM=WRITING_ALL_STATE;
    103c:	89 e0       	ldi	r24, 0x09	; 9
    103e:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    1042:	06 c1       	rjmp	.+524    	; 0x1250 <NVM_Main+0x276>
		}
		break;
		case  WRITING_ALL_STATE:
		if(gu8_WriteDone==DONE)
    1044:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <gu8_WriteDone>
    1048:	81 30       	cpi	r24, 0x01	; 1
    104a:	09 f0       	breq	.+2      	; 0x104e <NVM_Main+0x74>
    104c:	01 c1       	rjmp	.+514    	; 0x1250 <NVM_Main+0x276>
		{
			gu8_WriteDone=NOT_YET;
    104e:	10 92 ac 03 	sts	0x03AC, r1	; 0x8003ac <gu8_WriteDone>
			gu8_NVM_SM=WRITE_ALL_STATE;
    1052:	82 e0       	ldi	r24, 0x02	; 2
    1054:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    1058:	fb c0       	rjmp	.+502    	; 0x1250 <NVM_Main+0x276>
		}
		break;
		case READ_ALL_STATE:   
			if(au8_ID_count==NVM_NUM_OF_BLOCKS)
    105a:	e0 91 a9 03 	lds	r30, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    105e:	e2 30       	cpi	r30, 0x02	; 2
    1060:	21 f4       	brne	.+8      	; 0x106a <NVM_Main+0x90>
			{
				gu8_NVM_SM=READ_ALL_DONE_STATE;
    1062:	83 e0       	ldi	r24, 0x03	; 3
    1064:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    1068:	f3 c0       	rjmp	.+486    	; 0x1250 <NVM_Main+0x276>
				
			}
			else
			{

				MEMIF_ReqReadBlock(NVM_BlocConfig[au8_ID_count].BlockId,NVM_BlocConfig[au8_ID_count].BlockRamAddress);
    106a:	f0 e0       	ldi	r31, 0x00	; 0
    106c:	ee 0f       	add	r30, r30
    106e:	ff 1f       	adc	r31, r31
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	eb 59       	subi	r30, 0x9B	; 155
    107a:	ff 4f       	sbci	r31, 0xFF	; 255
    107c:	62 81       	ldd	r22, Z+2	; 0x02
    107e:	73 81       	ldd	r23, Z+3	; 0x03
    1080:	80 81       	ld	r24, Z
    1082:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <MEMIF_ReqReadBlock>
				au8_ID_count++;
    1086:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    108a:	8f 5f       	subi	r24, 0xFF	; 255
    108c:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <au8_ID_count.1721>
				gu8_NVM_SM=READING_ALL_STATE;
    1090:	8a e0       	ldi	r24, 0x0A	; 10
    1092:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    1096:	dc c0       	rjmp	.+440    	; 0x1250 <NVM_Main+0x276>
			}
			break;
		case  WRITE_BLOCK_STATE:
				for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    1098:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
				{
					if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Write_ID)
    109c:	80 91 af 03 	lds	r24, 0x03AF	; 0x8003af <gu8_Write_ID>
    10a0:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <NVM_BlocConfig>
    10a4:	98 13       	cpse	r25, r24
    10a6:	cc c0       	rjmp	.+408    	; 0x1240 <NVM_Main+0x266>
    10a8:	a0 e0       	ldi	r26, 0x00	; 0
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	02 c0       	rjmp	.+4      	; 0x10b2 <NVM_Main+0xd8>
    10ae:	a1 e0       	ldi	r26, 0x01	; 1
    10b0:	b0 e0       	ldi	r27, 0x00	; 0
					{
						for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    10b2:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <au8_LEN_Count.1722>
    10b6:	fd 01       	movw	r30, r26
    10b8:	ee 0f       	add	r30, r30
    10ba:	ff 1f       	adc	r31, r31
    10bc:	ee 0f       	add	r30, r30
    10be:	ff 1f       	adc	r31, r31
    10c0:	ee 0f       	add	r30, r30
    10c2:	ff 1f       	adc	r31, r31
    10c4:	eb 59       	subi	r30, 0x9B	; 155
    10c6:	ff 4f       	sbci	r31, 0xFF	; 255
    10c8:	81 81       	ldd	r24, Z+1	; 0x01
    10ca:	88 23       	and	r24, r24
    10cc:	f9 f0       	breq	.+62     	; 0x110c <NVM_Main+0x132>
						NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count]=gu8ptr_WriteData[au8_LEN_Count];
    10ce:	60 91 ad 03 	lds	r22, 0x03AD	; 0x8003ad <gu8ptr_WriteData>
    10d2:	70 91 ae 03 	lds	r23, 0x03AE	; 0x8003ae <gu8ptr_WriteData+0x1>
    10d6:	20 e0       	ldi	r18, 0x00	; 0
    10d8:	df 01       	movw	r26, r30
    10da:	ef 01       	movw	r28, r30
    10dc:	22 96       	adiw	r28, 0x02	; 2
		case  WRITE_BLOCK_STATE:
				for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
				{
					if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Write_ID)
					{
						for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    10de:	11 96       	adiw	r26, 0x01	; 1
						NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count]=gu8ptr_WriteData[au8_LEN_Count];
    10e0:	82 2f       	mov	r24, r18
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	fb 01       	movw	r30, r22
    10e6:	e8 0f       	add	r30, r24
    10e8:	f9 1f       	adc	r31, r25
    10ea:	30 81       	ld	r19, Z
    10ec:	48 81       	ld	r20, Y
    10ee:	59 81       	ldd	r21, Y+1	; 0x01
    10f0:	fa 01       	movw	r30, r20
    10f2:	e8 0f       	add	r30, r24
    10f4:	f9 1f       	adc	r31, r25
    10f6:	30 83       	st	Z, r19
		case  WRITE_BLOCK_STATE:
				for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
				{
					if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Write_ID)
					{
						for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    10f8:	2f 5f       	subi	r18, 0xFF	; 255
    10fa:	8c 91       	ld	r24, X
    10fc:	28 17       	cp	r18, r24
    10fe:	80 f3       	brcs	.-32     	; 0x10e0 <NVM_Main+0x106>
    1100:	20 93 aa 03 	sts	0x03AA, r18	; 0x8003aa <au8_LEN_Count.1722>
    1104:	03 c0       	rjmp	.+6      	; 0x110c <NVM_Main+0x132>
				au8_ID_count++;
				gu8_NVM_SM=READING_ALL_STATE;
			}
			break;
		case  WRITE_BLOCK_STATE:
				for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    1106:	82 e0       	ldi	r24, 0x02	; 2
    1108:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <au8_ID_count.1721>
						for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
						NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count]=gu8ptr_WriteData[au8_LEN_Count];
						break;
					}
				}
				gu8_NVM_SM=WRITE_BLOCK_DONE_STATE;
    110c:	88 e0       	ldi	r24, 0x08	; 8
    110e:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
				break;
    1112:	9e c0       	rjmp	.+316    	; 0x1250 <NVM_Main+0x276>
		case  WRITE_BLOCK_DONE_STATE:
				gu8_NVMbusy_flag=FREE;
    1114:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
				NVM_BlocConfig[au8_ID_count].BlockWriteNotifPtr();
    1118:	e0 91 a9 03 	lds	r30, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    111c:	f0 e0       	ldi	r31, 0x00	; 0
    111e:	ee 0f       	add	r30, r30
    1120:	ff 1f       	adc	r31, r31
    1122:	ee 0f       	add	r30, r30
    1124:	ff 1f       	adc	r31, r31
    1126:	ee 0f       	add	r30, r30
    1128:	ff 1f       	adc	r31, r31
    112a:	eb 59       	subi	r30, 0x9B	; 155
    112c:	ff 4f       	sbci	r31, 0xFF	; 255
    112e:	04 80       	ldd	r0, Z+4	; 0x04
    1130:	f5 81       	ldd	r31, Z+5	; 0x05
    1132:	e0 2d       	mov	r30, r0
    1134:	09 95       	icall
				au8_ID_count=0;
    1136:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
				au8_LEN_Count=0;
    113a:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <au8_LEN_Count.1722>
				gu8_NVM_SM=IDLE_STATE;
    113e:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <gu8_NVM_SM>
				break;
    1142:	86 c0       	rjmp	.+268    	; 0x1250 <NVM_Main+0x276>
		case  READ_BLOCK_STATE:
		for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    1144:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
		{
			if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Read_ID)
    1148:	80 91 b2 03 	lds	r24, 0x03B2	; 0x8003b2 <gu8_Read_ID>
    114c:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <NVM_BlocConfig>
    1150:	98 13       	cpse	r25, r24
    1152:	6e c0       	rjmp	.+220    	; 0x1230 <NVM_Main+0x256>
    1154:	a0 e0       	ldi	r26, 0x00	; 0
    1156:	b0 e0       	ldi	r27, 0x00	; 0
    1158:	02 c0       	rjmp	.+4      	; 0x115e <NVM_Main+0x184>
    115a:	a1 e0       	ldi	r26, 0x01	; 1
    115c:	b0 e0       	ldi	r27, 0x00	; 0
			{
				for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    115e:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <au8_LEN_Count.1722>
    1162:	fd 01       	movw	r30, r26
    1164:	ee 0f       	add	r30, r30
    1166:	ff 1f       	adc	r31, r31
    1168:	ee 0f       	add	r30, r30
    116a:	ff 1f       	adc	r31, r31
    116c:	ee 0f       	add	r30, r30
    116e:	ff 1f       	adc	r31, r31
    1170:	eb 59       	subi	r30, 0x9B	; 155
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	81 81       	ldd	r24, Z+1	; 0x01
    1176:	88 23       	and	r24, r24
    1178:	f1 f0       	breq	.+60     	; 0x11b6 <NVM_Main+0x1dc>
				gu8ptr_ReadData[au8_LEN_Count]=NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count];
    117a:	40 91 b0 03 	lds	r20, 0x03B0	; 0x8003b0 <gu8ptr_ReadData>
    117e:	50 91 b1 03 	lds	r21, 0x03B1	; 0x8003b1 <gu8ptr_ReadData+0x1>
    1182:	20 e0       	ldi	r18, 0x00	; 0
    1184:	df 01       	movw	r26, r30
    1186:	ef 01       	movw	r28, r30
    1188:	22 96       	adiw	r28, 0x02	; 2
		case  READ_BLOCK_STATE:
		for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
		{
			if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Read_ID)
			{
				for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    118a:	11 96       	adiw	r26, 0x01	; 1
				gu8ptr_ReadData[au8_LEN_Count]=NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count];
    118c:	82 2f       	mov	r24, r18
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	e8 81       	ld	r30, Y
    1192:	f9 81       	ldd	r31, Y+1	; 0x01
    1194:	e8 0f       	add	r30, r24
    1196:	f9 1f       	adc	r31, r25
    1198:	30 81       	ld	r19, Z
    119a:	fa 01       	movw	r30, r20
    119c:	e8 0f       	add	r30, r24
    119e:	f9 1f       	adc	r31, r25
    11a0:	30 83       	st	Z, r19
		case  READ_BLOCK_STATE:
		for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
		{
			if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Read_ID)
			{
				for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
    11a2:	2f 5f       	subi	r18, 0xFF	; 255
    11a4:	8c 91       	ld	r24, X
    11a6:	28 17       	cp	r18, r24
    11a8:	88 f3       	brcs	.-30     	; 0x118c <NVM_Main+0x1b2>
    11aa:	20 93 aa 03 	sts	0x03AA, r18	; 0x8003aa <au8_LEN_Count.1722>
    11ae:	03 c0       	rjmp	.+6      	; 0x11b6 <NVM_Main+0x1dc>
				au8_ID_count=0;
				au8_LEN_Count=0;
				gu8_NVM_SM=IDLE_STATE;
				break;
		case  READ_BLOCK_STATE:
		for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    11b0:	82 e0       	ldi	r24, 0x02	; 2
    11b2:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <au8_ID_count.1721>
				for(au8_LEN_Count=0;au8_LEN_Count<NVM_BlocConfig[au8_ID_count].BlockLength;au8_LEN_Count++)
				gu8ptr_ReadData[au8_LEN_Count]=NVM_BlocConfig[au8_ID_count].BlockRamAddress[au8_LEN_Count];
				break;
			}
		}
		gu8_NVM_SM=READ_BLOCK_DONE_STATE;
    11b6:	87 e0       	ldi	r24, 0x07	; 7
    11b8:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
		break;
    11bc:	49 c0       	rjmp	.+146    	; 0x1250 <NVM_Main+0x276>
		case  READ_BLOCK_DONE_STATE:
		gu8_NVMbusy_flag=FREE;
    11be:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
		NVM_BlocConfig[au8_ID_count].BlockReadNotifPtr();
    11c2:	e0 91 a9 03 	lds	r30, 0x03A9	; 0x8003a9 <au8_ID_count.1721>
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
    11c8:	ee 0f       	add	r30, r30
    11ca:	ff 1f       	adc	r31, r31
    11cc:	ee 0f       	add	r30, r30
    11ce:	ff 1f       	adc	r31, r31
    11d0:	ee 0f       	add	r30, r30
    11d2:	ff 1f       	adc	r31, r31
    11d4:	eb 59       	subi	r30, 0x9B	; 155
    11d6:	ff 4f       	sbci	r31, 0xFF	; 255
    11d8:	06 80       	ldd	r0, Z+6	; 0x06
    11da:	f7 81       	ldd	r31, Z+7	; 0x07
    11dc:	e0 2d       	mov	r30, r0
    11de:	09 95       	icall
		au8_ID_count=0;
    11e0:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
		au8_LEN_Count=0;
    11e4:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <au8_LEN_Count.1722>
		gu8_NVM_SM=IDLE_STATE;
    11e8:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <gu8_NVM_SM>
		break;
    11ec:	31 c0       	rjmp	.+98     	; 0x1250 <NVM_Main+0x276>
		case  READING_ALL_STATE:
		if(gu8_ReadDone==DONE)
    11ee:	80 91 ab 03 	lds	r24, 0x03AB	; 0x8003ab <gu8_ReadDone>
    11f2:	81 30       	cpi	r24, 0x01	; 1
    11f4:	69 f5       	brne	.+90     	; 0x1250 <NVM_Main+0x276>
		{

			gu8_ReadDone=NOT_YET;
    11f6:	10 92 ab 03 	sts	0x03AB, r1	; 0x8003ab <gu8_ReadDone>
			gu8_NVM_SM=READ_ALL_STATE;
    11fa:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <gu8_NVM_SM>
    11fe:	28 c0       	rjmp	.+80     	; 0x1250 <NVM_Main+0x276>
			
		}
		break;
		case  READ_ALL_DONE_STATE:
				gu8_NVMbusy_flag=FREE;
    1200:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
				au8_ID_count=0;
    1204:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
				NVM_GlobalCallbacks.ReadAllCallback();
    1208:	e0 91 63 00 	lds	r30, 0x0063	; 0x800063 <NVM_GlobalCallbacks+0x2>
    120c:	f0 91 64 00 	lds	r31, 0x0064	; 0x800064 <NVM_GlobalCallbacks+0x3>
    1210:	09 95       	icall
				gu8_NVM_SM=IDLE_STATE;
    1212:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <gu8_NVM_SM>
		break;
    1216:	1c c0       	rjmp	.+56     	; 0x1250 <NVM_Main+0x276>
		case  WRITE_ALL_DONE_STATE:
				gu8_NVMbusy_flag=FREE;
    1218:	10 92 b3 03 	sts	0x03B3, r1	; 0x8003b3 <gu8_NVMbusy_flag>
				au8_ID_count=0;
    121c:	10 92 a9 03 	sts	0x03A9, r1	; 0x8003a9 <au8_ID_count.1721>
				NVM_GlobalCallbacks.WriteAllCallBack();
    1220:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <NVM_GlobalCallbacks>
    1224:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <NVM_GlobalCallbacks+0x1>
    1228:	09 95       	icall
				gu8_NVM_SM=IDLE_STATE;
    122a:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <gu8_NVM_SM>
				break;
		default:
			  break;
	}

}
    122e:	10 c0       	rjmp	.+32     	; 0x1250 <NVM_Main+0x276>
				au8_ID_count=0;
				au8_LEN_Count=0;
				gu8_NVM_SM=IDLE_STATE;
				break;
		case  READ_BLOCK_STATE:
		for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    1230:	91 e0       	ldi	r25, 0x01	; 1
    1232:	90 93 a9 03 	sts	0x03A9, r25	; 0x8003a9 <au8_ID_count.1721>
		{
			if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Read_ID)
    1236:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <NVM_BlocConfig+0x8>
    123a:	98 13       	cpse	r25, r24
    123c:	b9 cf       	rjmp	.-142    	; 0x11b0 <NVM_Main+0x1d6>
    123e:	8d cf       	rjmp	.-230    	; 0x115a <NVM_Main+0x180>
				au8_ID_count++;
				gu8_NVM_SM=READING_ALL_STATE;
			}
			break;
		case  WRITE_BLOCK_STATE:
				for(au8_ID_count=0;au8_ID_count<NVM_NUM_OF_BLOCKS;au8_ID_count++)
    1240:	91 e0       	ldi	r25, 0x01	; 1
    1242:	90 93 a9 03 	sts	0x03A9, r25	; 0x8003a9 <au8_ID_count.1721>
				{
					if(NVM_BlocConfig[au8_ID_count].BlockId==gu8_Write_ID)
    1246:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <NVM_BlocConfig+0x8>
    124a:	98 13       	cpse	r25, r24
    124c:	5c cf       	rjmp	.-328    	; 0x1106 <NVM_Main+0x12c>
    124e:	2f cf       	rjmp	.-418    	; 0x10ae <NVM_Main+0xd4>
				break;
		default:
			  break;
	}

}
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	08 95       	ret

00001256 <NVM_WriteBlockDoneNotif>:



void NVM_WriteBlockDoneNotif(void)
{
	gu8_WriteDone=DONE;
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	80 93 ac 03 	sts	0x03AC, r24	; 0x8003ac <gu8_WriteDone>
    125c:	08 95       	ret

0000125e <NVM_ReadBlockDoneNotif>:
}

void NVM_ReadBlockDoneNotif(void)
{
	gu8_ReadDone=DONE;
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	80 93 ab 03 	sts	0x03AB, r24	; 0x8003ab <gu8_ReadDone>
    1264:	08 95       	ret

00001266 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1266:	31 e1       	ldi	r19, 0x11	; 17
    1268:	fc 01       	movw	r30, r24
    126a:	30 83       	st	Z, r19
    126c:	31 97       	sbiw	r30, 0x01	; 1
    126e:	22 e2       	ldi	r18, 0x22	; 34
    1270:	20 83       	st	Z, r18
    1272:	31 97       	sbiw	r30, 0x01	; 1
    1274:	a3 e3       	ldi	r26, 0x33	; 51
    1276:	a0 83       	st	Z, r26
    1278:	31 97       	sbiw	r30, 0x01	; 1
    127a:	60 83       	st	Z, r22
    127c:	31 97       	sbiw	r30, 0x01	; 1
    127e:	70 83       	st	Z, r23
    1280:	31 97       	sbiw	r30, 0x01	; 1
    1282:	10 82       	st	Z, r1
    1284:	31 97       	sbiw	r30, 0x01	; 1
    1286:	60 e8       	ldi	r22, 0x80	; 128
    1288:	60 83       	st	Z, r22
    128a:	31 97       	sbiw	r30, 0x01	; 1
    128c:	10 82       	st	Z, r1
    128e:	31 97       	sbiw	r30, 0x01	; 1
    1290:	62 e0       	ldi	r22, 0x02	; 2
    1292:	60 83       	st	Z, r22
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	63 e0       	ldi	r22, 0x03	; 3
    1298:	60 83       	st	Z, r22
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	64 e0       	ldi	r22, 0x04	; 4
    129e:	60 83       	st	Z, r22
    12a0:	31 97       	sbiw	r30, 0x01	; 1
    12a2:	65 e0       	ldi	r22, 0x05	; 5
    12a4:	60 83       	st	Z, r22
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	66 e0       	ldi	r22, 0x06	; 6
    12aa:	60 83       	st	Z, r22
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	67 e0       	ldi	r22, 0x07	; 7
    12b0:	60 83       	st	Z, r22
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	68 e0       	ldi	r22, 0x08	; 8
    12b6:	60 83       	st	Z, r22
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	69 e0       	ldi	r22, 0x09	; 9
    12bc:	60 83       	st	Z, r22
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	60 e1       	ldi	r22, 0x10	; 16
    12c2:	60 83       	st	Z, r22
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	30 83       	st	Z, r19
    12c8:	31 97       	sbiw	r30, 0x01	; 1
    12ca:	32 e1       	ldi	r19, 0x12	; 18
    12cc:	30 83       	st	Z, r19
    12ce:	31 97       	sbiw	r30, 0x01	; 1
    12d0:	33 e1       	ldi	r19, 0x13	; 19
    12d2:	30 83       	st	Z, r19
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	34 e1       	ldi	r19, 0x14	; 20
    12d8:	30 83       	st	Z, r19
    12da:	31 97       	sbiw	r30, 0x01	; 1
    12dc:	35 e1       	ldi	r19, 0x15	; 21
    12de:	30 83       	st	Z, r19
    12e0:	31 97       	sbiw	r30, 0x01	; 1
    12e2:	36 e1       	ldi	r19, 0x16	; 22
    12e4:	30 83       	st	Z, r19
    12e6:	31 97       	sbiw	r30, 0x01	; 1
    12e8:	37 e1       	ldi	r19, 0x17	; 23
    12ea:	30 83       	st	Z, r19
    12ec:	31 97       	sbiw	r30, 0x01	; 1
    12ee:	38 e1       	ldi	r19, 0x18	; 24
    12f0:	30 83       	st	Z, r19
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	39 e1       	ldi	r19, 0x19	; 25
    12f6:	30 83       	st	Z, r19
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	30 e2       	ldi	r19, 0x20	; 32
    12fc:	30 83       	st	Z, r19
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	31 e2       	ldi	r19, 0x21	; 33
    1302:	30 83       	st	Z, r19
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	20 83       	st	Z, r18
    1308:	31 97       	sbiw	r30, 0x01	; 1
    130a:	23 e2       	ldi	r18, 0x23	; 35
    130c:	20 83       	st	Z, r18
    130e:	31 97       	sbiw	r30, 0x01	; 1
    1310:	40 83       	st	Z, r20
    1312:	31 97       	sbiw	r30, 0x01	; 1
    1314:	50 83       	st	Z, r21
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	26 e2       	ldi	r18, 0x26	; 38
    131a:	20 83       	st	Z, r18
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	27 e2       	ldi	r18, 0x27	; 39
    1320:	20 83       	st	Z, r18
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	28 e2       	ldi	r18, 0x28	; 40
    1326:	20 83       	st	Z, r18
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	29 e2       	ldi	r18, 0x29	; 41
    132c:	20 83       	st	Z, r18
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	20 e3       	ldi	r18, 0x30	; 48
    1332:	20 83       	st	Z, r18
    1334:	31 97       	sbiw	r30, 0x01	; 1
    1336:	21 e3       	ldi	r18, 0x31	; 49
    1338:	20 83       	st	Z, r18
    133a:	86 97       	sbiw	r24, 0x26	; 38
    133c:	08 95       	ret

0000133e <xPortStartScheduler>:
    133e:	1b bc       	out	0x2b, r1	; 43
    1340:	8c e7       	ldi	r24, 0x7C	; 124
    1342:	8a bd       	out	0x2a, r24	; 42
    1344:	8b e0       	ldi	r24, 0x0B	; 11
    1346:	8e bd       	out	0x2e, r24	; 46
    1348:	89 b7       	in	r24, 0x39	; 57
    134a:	80 61       	ori	r24, 0x10	; 16
    134c:	89 bf       	out	0x39, r24	; 57
    134e:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <pxCurrentTCB>
    1352:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    1356:	cd 91       	ld	r28, X+
    1358:	cd bf       	out	0x3d, r28	; 61
    135a:	dd 91       	ld	r29, X+
    135c:	de bf       	out	0x3e, r29	; 62
    135e:	ff 91       	pop	r31
    1360:	ef 91       	pop	r30
    1362:	df 91       	pop	r29
    1364:	cf 91       	pop	r28
    1366:	bf 91       	pop	r27
    1368:	af 91       	pop	r26
    136a:	9f 91       	pop	r25
    136c:	8f 91       	pop	r24
    136e:	7f 91       	pop	r23
    1370:	6f 91       	pop	r22
    1372:	5f 91       	pop	r21
    1374:	4f 91       	pop	r20
    1376:	3f 91       	pop	r19
    1378:	2f 91       	pop	r18
    137a:	1f 91       	pop	r17
    137c:	0f 91       	pop	r16
    137e:	ff 90       	pop	r15
    1380:	ef 90       	pop	r14
    1382:	df 90       	pop	r13
    1384:	cf 90       	pop	r12
    1386:	bf 90       	pop	r11
    1388:	af 90       	pop	r10
    138a:	9f 90       	pop	r9
    138c:	8f 90       	pop	r8
    138e:	7f 90       	pop	r7
    1390:	6f 90       	pop	r6
    1392:	5f 90       	pop	r5
    1394:	4f 90       	pop	r4
    1396:	3f 90       	pop	r3
    1398:	2f 90       	pop	r2
    139a:	1f 90       	pop	r1
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	0f 90       	pop	r0
    13a2:	08 95       	ret
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	08 95       	ret

000013a8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13a8:	0f 92       	push	r0
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	0f 92       	push	r0
    13b0:	1f 92       	push	r1
    13b2:	11 24       	eor	r1, r1
    13b4:	2f 92       	push	r2
    13b6:	3f 92       	push	r3
    13b8:	4f 92       	push	r4
    13ba:	5f 92       	push	r5
    13bc:	6f 92       	push	r6
    13be:	7f 92       	push	r7
    13c0:	8f 92       	push	r8
    13c2:	9f 92       	push	r9
    13c4:	af 92       	push	r10
    13c6:	bf 92       	push	r11
    13c8:	cf 92       	push	r12
    13ca:	df 92       	push	r13
    13cc:	ef 92       	push	r14
    13ce:	ff 92       	push	r15
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	2f 93       	push	r18
    13d6:	3f 93       	push	r19
    13d8:	4f 93       	push	r20
    13da:	5f 93       	push	r21
    13dc:	6f 93       	push	r22
    13de:	7f 93       	push	r23
    13e0:	8f 93       	push	r24
    13e2:	9f 93       	push	r25
    13e4:	af 93       	push	r26
    13e6:	bf 93       	push	r27
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	ef 93       	push	r30
    13ee:	ff 93       	push	r31
    13f0:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <pxCurrentTCB>
    13f4:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    13f8:	0d b6       	in	r0, 0x3d	; 61
    13fa:	0d 92       	st	X+, r0
    13fc:	0e b6       	in	r0, 0x3e	; 62
    13fe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1400:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1404:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <pxCurrentTCB>
    1408:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    140c:	cd 91       	ld	r28, X+
    140e:	cd bf       	out	0x3d, r28	; 61
    1410:	dd 91       	ld	r29, X+
    1412:	de bf       	out	0x3e, r29	; 62
    1414:	ff 91       	pop	r31
    1416:	ef 91       	pop	r30
    1418:	df 91       	pop	r29
    141a:	cf 91       	pop	r28
    141c:	bf 91       	pop	r27
    141e:	af 91       	pop	r26
    1420:	9f 91       	pop	r25
    1422:	8f 91       	pop	r24
    1424:	7f 91       	pop	r23
    1426:	6f 91       	pop	r22
    1428:	5f 91       	pop	r21
    142a:	4f 91       	pop	r20
    142c:	3f 91       	pop	r19
    142e:	2f 91       	pop	r18
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	ff 90       	pop	r15
    1436:	ef 90       	pop	r14
    1438:	df 90       	pop	r13
    143a:	cf 90       	pop	r12
    143c:	bf 90       	pop	r11
    143e:	af 90       	pop	r10
    1440:	9f 90       	pop	r9
    1442:	8f 90       	pop	r8
    1444:	7f 90       	pop	r7
    1446:	6f 90       	pop	r6
    1448:	5f 90       	pop	r5
    144a:	4f 90       	pop	r4
    144c:	3f 90       	pop	r3
    144e:	2f 90       	pop	r2
    1450:	1f 90       	pop	r1
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1458:	08 95       	ret

0000145a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    145a:	0f 92       	push	r0
    145c:	0f b6       	in	r0, 0x3f	; 63
    145e:	f8 94       	cli
    1460:	0f 92       	push	r0
    1462:	1f 92       	push	r1
    1464:	11 24       	eor	r1, r1
    1466:	2f 92       	push	r2
    1468:	3f 92       	push	r3
    146a:	4f 92       	push	r4
    146c:	5f 92       	push	r5
    146e:	6f 92       	push	r6
    1470:	7f 92       	push	r7
    1472:	8f 92       	push	r8
    1474:	9f 92       	push	r9
    1476:	af 92       	push	r10
    1478:	bf 92       	push	r11
    147a:	cf 92       	push	r12
    147c:	df 92       	push	r13
    147e:	ef 92       	push	r14
    1480:	ff 92       	push	r15
    1482:	0f 93       	push	r16
    1484:	1f 93       	push	r17
    1486:	2f 93       	push	r18
    1488:	3f 93       	push	r19
    148a:	4f 93       	push	r20
    148c:	5f 93       	push	r21
    148e:	6f 93       	push	r22
    1490:	7f 93       	push	r23
    1492:	8f 93       	push	r24
    1494:	9f 93       	push	r25
    1496:	af 93       	push	r26
    1498:	bf 93       	push	r27
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	ef 93       	push	r30
    14a0:	ff 93       	push	r31
    14a2:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <pxCurrentTCB>
    14a6:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    14aa:	0d b6       	in	r0, 0x3d	; 61
    14ac:	0d 92       	st	X+, r0
    14ae:	0e b6       	in	r0, 0x3e	; 62
    14b0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    14b2:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <vTaskIncrementTick>
	vTaskSwitchContext();
    14b6:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14ba:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <pxCurrentTCB>
    14be:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    14c2:	cd 91       	ld	r28, X+
    14c4:	cd bf       	out	0x3d, r28	; 61
    14c6:	dd 91       	ld	r29, X+
    14c8:	de bf       	out	0x3e, r29	; 62
    14ca:	ff 91       	pop	r31
    14cc:	ef 91       	pop	r30
    14ce:	df 91       	pop	r29
    14d0:	cf 91       	pop	r28
    14d2:	bf 91       	pop	r27
    14d4:	af 91       	pop	r26
    14d6:	9f 91       	pop	r25
    14d8:	8f 91       	pop	r24
    14da:	7f 91       	pop	r23
    14dc:	6f 91       	pop	r22
    14de:	5f 91       	pop	r21
    14e0:	4f 91       	pop	r20
    14e2:	3f 91       	pop	r19
    14e4:	2f 91       	pop	r18
    14e6:	1f 91       	pop	r17
    14e8:	0f 91       	pop	r16
    14ea:	ff 90       	pop	r15
    14ec:	ef 90       	pop	r14
    14ee:	df 90       	pop	r13
    14f0:	cf 90       	pop	r12
    14f2:	bf 90       	pop	r11
    14f4:	af 90       	pop	r10
    14f6:	9f 90       	pop	r9
    14f8:	8f 90       	pop	r8
    14fa:	7f 90       	pop	r7
    14fc:	6f 90       	pop	r6
    14fe:	5f 90       	pop	r5
    1500:	4f 90       	pop	r4
    1502:	3f 90       	pop	r3
    1504:	2f 90       	pop	r2
    1506:	1f 90       	pop	r1
    1508:	0f 90       	pop	r0
    150a:	0f be       	out	0x3f, r0	; 63
    150c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    150e:	08 95       	ret

00001510 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1510:	0e 94 2d 0a 	call	0x145a	; 0x145a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1514:	18 95       	reti

00001516 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	ec 01       	movw	r28, r24
    151c:	e0 91 07 04 	lds	r30, 0x0407	; 0x800407 <pxCurrentTCB>
    1520:	f0 91 08 04 	lds	r31, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    1524:	93 83       	std	Z+3, r25	; 0x03
    1526:	82 83       	std	Z+2, r24	; 0x02
    1528:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <xTickCount>
    152c:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    1530:	c8 17       	cp	r28, r24
    1532:	d9 07       	cpc	r29, r25
    1534:	68 f4       	brcc	.+26     	; 0x1550 <prvAddCurrentTaskToDelayedList+0x3a>
    1536:	60 91 07 04 	lds	r22, 0x0407	; 0x800407 <pxCurrentTCB>
    153a:	70 91 08 04 	lds	r23, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    153e:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <pxOverflowDelayedTaskList>
    1542:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <pxOverflowDelayedTaskList+0x1>
    1546:	6e 5f       	subi	r22, 0xFE	; 254
    1548:	7f 4f       	sbci	r23, 0xFF	; 255
    154a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vListInsert>
    154e:	17 c0       	rjmp	.+46     	; 0x157e <prvAddCurrentTaskToDelayedList+0x68>
    1550:	60 91 07 04 	lds	r22, 0x0407	; 0x800407 <pxCurrentTCB>
    1554:	70 91 08 04 	lds	r23, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    1558:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    155c:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    1560:	6e 5f       	subi	r22, 0xFE	; 254
    1562:	7f 4f       	sbci	r23, 0xFF	; 255
    1564:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vListInsert>
    1568:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <xNextTaskUnblockTime>
    156c:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <xNextTaskUnblockTime+0x1>
    1570:	c8 17       	cp	r28, r24
    1572:	d9 07       	cpc	r29, r25
    1574:	20 f4       	brcc	.+8      	; 0x157e <prvAddCurrentTaskToDelayedList+0x68>
    1576:	d0 93 76 00 	sts	0x0076, r29	; 0x800076 <xNextTaskUnblockTime+0x1>
    157a:	c0 93 75 00 	sts	0x0075, r28	; 0x800075 <xNextTaskUnblockTime>
    157e:	df 91       	pop	r29
    1580:	cf 91       	pop	r28
    1582:	08 95       	ret

00001584 <xTaskGenericCreate>:
    1584:	4f 92       	push	r4
    1586:	5f 92       	push	r5
    1588:	6f 92       	push	r6
    158a:	7f 92       	push	r7
    158c:	8f 92       	push	r8
    158e:	9f 92       	push	r9
    1590:	af 92       	push	r10
    1592:	bf 92       	push	r11
    1594:	cf 92       	push	r12
    1596:	df 92       	push	r13
    1598:	ef 92       	push	r14
    159a:	ff 92       	push	r15
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29
    15a4:	5c 01       	movw	r10, r24
    15a6:	4b 01       	movw	r8, r22
    15a8:	3a 01       	movw	r6, r20
    15aa:	29 01       	movw	r4, r18
    15ac:	81 e2       	ldi	r24, 0x21	; 33
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	0e 94 8a 03 	call	0x714	; 0x714 <pvPortMalloc>
    15b4:	ec 01       	movw	r28, r24
    15b6:	89 2b       	or	r24, r25
    15b8:	09 f4       	brne	.+2      	; 0x15bc <xTaskGenericCreate+0x38>
    15ba:	d3 c0       	rjmp	.+422    	; 0x1762 <xTaskGenericCreate+0x1de>
    15bc:	c1 14       	cp	r12, r1
    15be:	d1 04       	cpc	r13, r1
    15c0:	09 f0       	breq	.+2      	; 0x15c4 <xTaskGenericCreate+0x40>
    15c2:	cb c0       	rjmp	.+406    	; 0x175a <xTaskGenericCreate+0x1d6>
    15c4:	c3 01       	movw	r24, r6
    15c6:	0e 94 8a 03 	call	0x714	; 0x714 <pvPortMalloc>
    15ca:	98 8f       	std	Y+24, r25	; 0x18
    15cc:	8f 8b       	std	Y+23, r24	; 0x17
    15ce:	00 97       	sbiw	r24, 0x00	; 0
    15d0:	21 f4       	brne	.+8      	; 0x15da <xTaskGenericCreate+0x56>
    15d2:	ce 01       	movw	r24, r28
    15d4:	0e 94 b0 03 	call	0x760	; 0x760 <vPortFree>
    15d8:	c4 c0       	rjmp	.+392    	; 0x1762 <xTaskGenericCreate+0x1de>
    15da:	a3 01       	movw	r20, r6
    15dc:	65 ea       	ldi	r22, 0xA5	; 165
    15de:	70 e0       	ldi	r23, 0x00	; 0
    15e0:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <memset>
    15e4:	93 01       	movw	r18, r6
    15e6:	21 50       	subi	r18, 0x01	; 1
    15e8:	31 09       	sbc	r19, r1
    15ea:	8f 89       	ldd	r24, Y+23	; 0x17
    15ec:	98 8d       	ldd	r25, Y+24	; 0x18
    15ee:	3c 01       	movw	r6, r24
    15f0:	62 0e       	add	r6, r18
    15f2:	73 1e       	adc	r7, r19
    15f4:	48 e0       	ldi	r20, 0x08	; 8
    15f6:	50 e0       	ldi	r21, 0x00	; 0
    15f8:	b4 01       	movw	r22, r8
    15fa:	ce 01       	movw	r24, r28
    15fc:	49 96       	adiw	r24, 0x19	; 25
    15fe:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <strncpy>
    1602:	18 a2       	std	Y+32, r1	; 0x20
    1604:	10 2f       	mov	r17, r16
    1606:	03 30       	cpi	r16, 0x03	; 3
    1608:	08 f0       	brcs	.+2      	; 0x160c <xTaskGenericCreate+0x88>
    160a:	12 e0       	ldi	r17, 0x02	; 2
    160c:	1e 8b       	std	Y+22, r17	; 0x16
    160e:	6e 01       	movw	r12, r28
    1610:	82 e0       	ldi	r24, 0x02	; 2
    1612:	c8 0e       	add	r12, r24
    1614:	d1 1c       	adc	r13, r1
    1616:	c6 01       	movw	r24, r12
    1618:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <vListInitialiseItem>
    161c:	ce 01       	movw	r24, r28
    161e:	0c 96       	adiw	r24, 0x0c	; 12
    1620:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <vListInitialiseItem>
    1624:	d9 87       	std	Y+9, r29	; 0x09
    1626:	c8 87       	std	Y+8, r28	; 0x08
    1628:	83 e0       	ldi	r24, 0x03	; 3
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	81 1b       	sub	r24, r17
    162e:	91 09       	sbc	r25, r1
    1630:	9d 87       	std	Y+13, r25	; 0x0d
    1632:	8c 87       	std	Y+12, r24	; 0x0c
    1634:	db 8b       	std	Y+19, r29	; 0x13
    1636:	ca 8b       	std	Y+18, r28	; 0x12
    1638:	a2 01       	movw	r20, r4
    163a:	b5 01       	movw	r22, r10
    163c:	c3 01       	movw	r24, r6
    163e:	0e 94 33 09 	call	0x1266	; 0x1266 <pxPortInitialiseStack>
    1642:	99 83       	std	Y+1, r25	; 0x01
    1644:	88 83       	st	Y, r24
    1646:	e1 14       	cp	r14, r1
    1648:	f1 04       	cpc	r15, r1
    164a:	19 f0       	breq	.+6      	; 0x1652 <xTaskGenericCreate+0xce>
    164c:	f7 01       	movw	r30, r14
    164e:	d1 83       	std	Z+1, r29	; 0x01
    1650:	c0 83       	st	Z, r28
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	0f 92       	push	r0
    1658:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <uxCurrentNumberOfTasks>
    165c:	8f 5f       	subi	r24, 0xFF	; 255
    165e:	80 93 c2 03 	sts	0x03C2, r24	; 0x8003c2 <uxCurrentNumberOfTasks>
    1662:	80 91 07 04 	lds	r24, 0x0407	; 0x800407 <pxCurrentTCB>
    1666:	90 91 08 04 	lds	r25, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    166a:	89 2b       	or	r24, r25
    166c:	89 f5       	brne	.+98     	; 0x16d0 <xTaskGenericCreate+0x14c>
    166e:	d0 93 08 04 	sts	0x0408, r29	; 0x800408 <pxCurrentTCB+0x1>
    1672:	c0 93 07 04 	sts	0x0407, r28	; 0x800407 <pxCurrentTCB>
    1676:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <uxCurrentNumberOfTasks>
    167a:	81 30       	cpi	r24, 0x01	; 1
    167c:	c1 f5       	brne	.+112    	; 0x16ee <xTaskGenericCreate+0x16a>
    167e:	8c ee       	ldi	r24, 0xEC	; 236
    1680:	93 e0       	ldi	r25, 0x03	; 3
    1682:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    1686:	85 ef       	ldi	r24, 0xF5	; 245
    1688:	93 e0       	ldi	r25, 0x03	; 3
    168a:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    168e:	8e ef       	ldi	r24, 0xFE	; 254
    1690:	93 e0       	ldi	r25, 0x03	; 3
    1692:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    1696:	83 ee       	ldi	r24, 0xE3	; 227
    1698:	93 e0       	ldi	r25, 0x03	; 3
    169a:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    169e:	8a ed       	ldi	r24, 0xDA	; 218
    16a0:	93 e0       	ldi	r25, 0x03	; 3
    16a2:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    16a6:	8d ec       	ldi	r24, 0xCD	; 205
    16a8:	93 e0       	ldi	r25, 0x03	; 3
    16aa:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    16ae:	84 ec       	ldi	r24, 0xC4	; 196
    16b0:	93 e0       	ldi	r25, 0x03	; 3
    16b2:	0e 94 6c 05 	call	0xad8	; 0xad8 <vListInitialise>
    16b6:	83 ee       	ldi	r24, 0xE3	; 227
    16b8:	93 e0       	ldi	r25, 0x03	; 3
    16ba:	90 93 d9 03 	sts	0x03D9, r25	; 0x8003d9 <pxDelayedTaskList+0x1>
    16be:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <pxDelayedTaskList>
    16c2:	8a ed       	ldi	r24, 0xDA	; 218
    16c4:	93 e0       	ldi	r25, 0x03	; 3
    16c6:	90 93 d7 03 	sts	0x03D7, r25	; 0x8003d7 <pxOverflowDelayedTaskList+0x1>
    16ca:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <pxOverflowDelayedTaskList>
    16ce:	0f c0       	rjmp	.+30     	; 0x16ee <xTaskGenericCreate+0x16a>
    16d0:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xSchedulerRunning>
    16d4:	81 11       	cpse	r24, r1
    16d6:	0b c0       	rjmp	.+22     	; 0x16ee <xTaskGenericCreate+0x16a>
    16d8:	e0 91 07 04 	lds	r30, 0x0407	; 0x800407 <pxCurrentTCB>
    16dc:	f0 91 08 04 	lds	r31, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    16e0:	86 89       	ldd	r24, Z+22	; 0x16
    16e2:	08 17       	cp	r16, r24
    16e4:	20 f0       	brcs	.+8      	; 0x16ee <xTaskGenericCreate+0x16a>
    16e6:	d0 93 08 04 	sts	0x0408, r29	; 0x800408 <pxCurrentTCB+0x1>
    16ea:	c0 93 07 04 	sts	0x0407, r28	; 0x800407 <pxCurrentTCB>
    16ee:	8e 89       	ldd	r24, Y+22	; 0x16
    16f0:	90 91 bf 03 	lds	r25, 0x03BF	; 0x8003bf <uxTopUsedPriority>
    16f4:	98 17       	cp	r25, r24
    16f6:	10 f4       	brcc	.+4      	; 0x16fc <xTaskGenericCreate+0x178>
    16f8:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <uxTopUsedPriority>
    16fc:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <uxTaskNumber>
    1700:	9f 5f       	subi	r25, 0xFF	; 255
    1702:	90 93 b8 03 	sts	0x03B8, r25	; 0x8003b8 <uxTaskNumber>
    1706:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <uxTopReadyPriority>
    170a:	98 17       	cp	r25, r24
    170c:	10 f4       	brcc	.+4      	; 0x1712 <xTaskGenericCreate+0x18e>
    170e:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <uxTopReadyPriority>
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	9c 01       	movw	r18, r24
    1716:	22 0f       	add	r18, r18
    1718:	33 1f       	adc	r19, r19
    171a:	22 0f       	add	r18, r18
    171c:	33 1f       	adc	r19, r19
    171e:	22 0f       	add	r18, r18
    1720:	33 1f       	adc	r19, r19
    1722:	82 0f       	add	r24, r18
    1724:	93 1f       	adc	r25, r19
    1726:	b6 01       	movw	r22, r12
    1728:	84 51       	subi	r24, 0x14	; 20
    172a:	9c 4f       	sbci	r25, 0xFC	; 252
    172c:	0e 94 7e 05 	call	0xafc	; 0xafc <vListInsertEnd>
    1730:	0f 90       	pop	r0
    1732:	0f be       	out	0x3f, r0	; 63
    1734:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xSchedulerRunning>
    1738:	88 23       	and	r24, r24
    173a:	59 f0       	breq	.+22     	; 0x1752 <xTaskGenericCreate+0x1ce>
    173c:	e0 91 07 04 	lds	r30, 0x0407	; 0x800407 <pxCurrentTCB>
    1740:	f0 91 08 04 	lds	r31, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    1744:	86 89       	ldd	r24, Z+22	; 0x16
    1746:	80 17       	cp	r24, r16
    1748:	30 f4       	brcc	.+12     	; 0x1756 <xTaskGenericCreate+0x1d2>
    174a:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vPortYield>
    174e:	81 e0       	ldi	r24, 0x01	; 1
    1750:	09 c0       	rjmp	.+18     	; 0x1764 <xTaskGenericCreate+0x1e0>
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	07 c0       	rjmp	.+14     	; 0x1764 <xTaskGenericCreate+0x1e0>
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	05 c0       	rjmp	.+10     	; 0x1764 <xTaskGenericCreate+0x1e0>
    175a:	d8 8e       	std	Y+24, r13	; 0x18
    175c:	cf 8a       	std	Y+23, r12	; 0x17
    175e:	c6 01       	movw	r24, r12
    1760:	3c cf       	rjmp	.-392    	; 0x15da <xTaskGenericCreate+0x56>
    1762:	8f ef       	ldi	r24, 0xFF	; 255
    1764:	df 91       	pop	r29
    1766:	cf 91       	pop	r28
    1768:	1f 91       	pop	r17
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	df 90       	pop	r13
    1772:	cf 90       	pop	r12
    1774:	bf 90       	pop	r11
    1776:	af 90       	pop	r10
    1778:	9f 90       	pop	r9
    177a:	8f 90       	pop	r8
    177c:	7f 90       	pop	r7
    177e:	6f 90       	pop	r6
    1780:	5f 90       	pop	r5
    1782:	4f 90       	pop	r4
    1784:	08 95       	ret

00001786 <vTaskStartScheduler>:
    1786:	af 92       	push	r10
    1788:	bf 92       	push	r11
    178a:	cf 92       	push	r12
    178c:	df 92       	push	r13
    178e:	ef 92       	push	r14
    1790:	ff 92       	push	r15
    1792:	0f 93       	push	r16
    1794:	a1 2c       	mov	r10, r1
    1796:	b1 2c       	mov	r11, r1
    1798:	c1 2c       	mov	r12, r1
    179a:	d1 2c       	mov	r13, r1
    179c:	e1 2c       	mov	r14, r1
    179e:	f1 2c       	mov	r15, r1
    17a0:	00 e0       	ldi	r16, 0x00	; 0
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	45 e5       	ldi	r20, 0x55	; 85
    17a8:	50 e0       	ldi	r21, 0x00	; 0
    17aa:	6e e1       	ldi	r22, 0x1E	; 30
    17ac:	71 e0       	ldi	r23, 0x01	; 1
    17ae:	8e e5       	ldi	r24, 0x5E	; 94
    17b0:	9d e0       	ldi	r25, 0x0D	; 13
    17b2:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xTaskGenericCreate>
    17b6:	81 30       	cpi	r24, 0x01	; 1
    17b8:	49 f4       	brne	.+18     	; 0x17cc <vTaskStartScheduler+0x46>
    17ba:	f8 94       	cli
    17bc:	80 93 bd 03 	sts	0x03BD, r24	; 0x8003bd <xSchedulerRunning>
    17c0:	10 92 c1 03 	sts	0x03C1, r1	; 0x8003c1 <xTickCount+0x1>
    17c4:	10 92 c0 03 	sts	0x03C0, r1	; 0x8003c0 <xTickCount>
    17c8:	0e 94 9f 09 	call	0x133e	; 0x133e <xPortStartScheduler>
    17cc:	0f 91       	pop	r16
    17ce:	ff 90       	pop	r15
    17d0:	ef 90       	pop	r14
    17d2:	df 90       	pop	r13
    17d4:	cf 90       	pop	r12
    17d6:	bf 90       	pop	r11
    17d8:	af 90       	pop	r10
    17da:	08 95       	ret

000017dc <vTaskSuspendAll>:
    17dc:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <uxSchedulerSuspended>
    17e0:	8f 5f       	subi	r24, 0xFF	; 255
    17e2:	80 93 bc 03 	sts	0x03BC, r24	; 0x8003bc <uxSchedulerSuspended>
    17e6:	08 95       	ret

000017e8 <vTaskIncrementTick>:
    17e8:	0f 93       	push	r16
    17ea:	1f 93       	push	r17
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <uxSchedulerSuspended>
    17f4:	81 11       	cpse	r24, r1
    17f6:	b2 c0       	rjmp	.+356    	; 0x195c <vTaskIncrementTick+0x174>
    17f8:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <xTickCount>
    17fc:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    1800:	01 96       	adiw	r24, 0x01	; 1
    1802:	90 93 c1 03 	sts	0x03C1, r25	; 0x8003c1 <xTickCount+0x1>
    1806:	80 93 c0 03 	sts	0x03C0, r24	; 0x8003c0 <xTickCount>
    180a:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <xTickCount>
    180e:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    1812:	89 2b       	or	r24, r25
    1814:	99 f5       	brne	.+102    	; 0x187c <vTaskIncrementTick+0x94>
    1816:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    181a:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    181e:	20 91 d6 03 	lds	r18, 0x03D6	; 0x8003d6 <pxOverflowDelayedTaskList>
    1822:	30 91 d7 03 	lds	r19, 0x03D7	; 0x8003d7 <pxOverflowDelayedTaskList+0x1>
    1826:	30 93 d9 03 	sts	0x03D9, r19	; 0x8003d9 <pxDelayedTaskList+0x1>
    182a:	20 93 d8 03 	sts	0x03D8, r18	; 0x8003d8 <pxDelayedTaskList>
    182e:	90 93 d7 03 	sts	0x03D7, r25	; 0x8003d7 <pxOverflowDelayedTaskList+0x1>
    1832:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <pxOverflowDelayedTaskList>
    1836:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <xNumOfOverflows>
    183a:	8f 5f       	subi	r24, 0xFF	; 255
    183c:	80 93 b9 03 	sts	0x03B9, r24	; 0x8003b9 <xNumOfOverflows>
    1840:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    1844:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    1848:	80 81       	ld	r24, Z
    184a:	81 11       	cpse	r24, r1
    184c:	07 c0       	rjmp	.+14     	; 0x185c <vTaskIncrementTick+0x74>
    184e:	8f ef       	ldi	r24, 0xFF	; 255
    1850:	9f ef       	ldi	r25, 0xFF	; 255
    1852:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <xNextTaskUnblockTime+0x1>
    1856:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <xNextTaskUnblockTime>
    185a:	10 c0       	rjmp	.+32     	; 0x187c <vTaskIncrementTick+0x94>
    185c:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    1860:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    1864:	05 80       	ldd	r0, Z+5	; 0x05
    1866:	f6 81       	ldd	r31, Z+6	; 0x06
    1868:	e0 2d       	mov	r30, r0
    186a:	06 80       	ldd	r0, Z+6	; 0x06
    186c:	f7 81       	ldd	r31, Z+7	; 0x07
    186e:	e0 2d       	mov	r30, r0
    1870:	82 81       	ldd	r24, Z+2	; 0x02
    1872:	93 81       	ldd	r25, Z+3	; 0x03
    1874:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <xNextTaskUnblockTime+0x1>
    1878:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <xNextTaskUnblockTime>
    187c:	20 91 c0 03 	lds	r18, 0x03C0	; 0x8003c0 <xTickCount>
    1880:	30 91 c1 03 	lds	r19, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    1884:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <xNextTaskUnblockTime>
    1888:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <xNextTaskUnblockTime+0x1>
    188c:	28 17       	cp	r18, r24
    188e:	39 07       	cpc	r19, r25
    1890:	08 f4       	brcc	.+2      	; 0x1894 <vTaskIncrementTick+0xac>
    1892:	69 c0       	rjmp	.+210    	; 0x1966 <vTaskIncrementTick+0x17e>
    1894:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    1898:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    189c:	80 81       	ld	r24, Z
    189e:	88 23       	and	r24, r24
    18a0:	99 f0       	breq	.+38     	; 0x18c8 <vTaskIncrementTick+0xe0>
    18a2:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    18a6:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    18aa:	05 80       	ldd	r0, Z+5	; 0x05
    18ac:	f6 81       	ldd	r31, Z+6	; 0x06
    18ae:	e0 2d       	mov	r30, r0
    18b0:	c6 81       	ldd	r28, Z+6	; 0x06
    18b2:	d7 81       	ldd	r29, Z+7	; 0x07
    18b4:	8a 81       	ldd	r24, Y+2	; 0x02
    18b6:	9b 81       	ldd	r25, Y+3	; 0x03
    18b8:	20 91 c0 03 	lds	r18, 0x03C0	; 0x8003c0 <xTickCount>
    18bc:	30 91 c1 03 	lds	r19, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    18c0:	28 17       	cp	r18, r24
    18c2:	39 07       	cpc	r19, r25
    18c4:	f8 f4       	brcc	.+62     	; 0x1904 <vTaskIncrementTick+0x11c>
    18c6:	19 c0       	rjmp	.+50     	; 0x18fa <vTaskIncrementTick+0x112>
    18c8:	8f ef       	ldi	r24, 0xFF	; 255
    18ca:	9f ef       	ldi	r25, 0xFF	; 255
    18cc:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <xNextTaskUnblockTime+0x1>
    18d0:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <xNextTaskUnblockTime>
    18d4:	48 c0       	rjmp	.+144    	; 0x1966 <vTaskIncrementTick+0x17e>
    18d6:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    18da:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    18de:	05 80       	ldd	r0, Z+5	; 0x05
    18e0:	f6 81       	ldd	r31, Z+6	; 0x06
    18e2:	e0 2d       	mov	r30, r0
    18e4:	c6 81       	ldd	r28, Z+6	; 0x06
    18e6:	d7 81       	ldd	r29, Z+7	; 0x07
    18e8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ea:	9b 81       	ldd	r25, Y+3	; 0x03
    18ec:	20 91 c0 03 	lds	r18, 0x03C0	; 0x8003c0 <xTickCount>
    18f0:	30 91 c1 03 	lds	r19, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    18f4:	28 17       	cp	r18, r24
    18f6:	39 07       	cpc	r19, r25
    18f8:	28 f4       	brcc	.+10     	; 0x1904 <vTaskIncrementTick+0x11c>
    18fa:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <xNextTaskUnblockTime+0x1>
    18fe:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <xNextTaskUnblockTime>
    1902:	31 c0       	rjmp	.+98     	; 0x1966 <vTaskIncrementTick+0x17e>
    1904:	8e 01       	movw	r16, r28
    1906:	0e 5f       	subi	r16, 0xFE	; 254
    1908:	1f 4f       	sbci	r17, 0xFF	; 255
    190a:	c8 01       	movw	r24, r16
    190c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
    1910:	8c 89       	ldd	r24, Y+20	; 0x14
    1912:	9d 89       	ldd	r25, Y+21	; 0x15
    1914:	89 2b       	or	r24, r25
    1916:	21 f0       	breq	.+8      	; 0x1920 <vTaskIncrementTick+0x138>
    1918:	ce 01       	movw	r24, r28
    191a:	0c 96       	adiw	r24, 0x0c	; 12
    191c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
    1920:	8e 89       	ldd	r24, Y+22	; 0x16
    1922:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <uxTopReadyPriority>
    1926:	98 17       	cp	r25, r24
    1928:	10 f4       	brcc	.+4      	; 0x192e <vTaskIncrementTick+0x146>
    192a:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <uxTopReadyPriority>
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	9c 01       	movw	r18, r24
    1932:	22 0f       	add	r18, r18
    1934:	33 1f       	adc	r19, r19
    1936:	22 0f       	add	r18, r18
    1938:	33 1f       	adc	r19, r19
    193a:	22 0f       	add	r18, r18
    193c:	33 1f       	adc	r19, r19
    193e:	82 0f       	add	r24, r18
    1940:	93 1f       	adc	r25, r19
    1942:	b8 01       	movw	r22, r16
    1944:	84 51       	subi	r24, 0x14	; 20
    1946:	9c 4f       	sbci	r25, 0xFC	; 252
    1948:	0e 94 7e 05 	call	0xafc	; 0xafc <vListInsertEnd>
    194c:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxDelayedTaskList>
    1950:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxDelayedTaskList+0x1>
    1954:	80 81       	ld	r24, Z
    1956:	81 11       	cpse	r24, r1
    1958:	be cf       	rjmp	.-132    	; 0x18d6 <vTaskIncrementTick+0xee>
    195a:	b6 cf       	rjmp	.-148    	; 0x18c8 <vTaskIncrementTick+0xe0>
    195c:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <uxMissedTicks>
    1960:	8f 5f       	subi	r24, 0xFF	; 255
    1962:	80 93 bb 03 	sts	0x03BB, r24	; 0x8003bb <uxMissedTicks>
    1966:	df 91       	pop	r29
    1968:	cf 91       	pop	r28
    196a:	1f 91       	pop	r17
    196c:	0f 91       	pop	r16
    196e:	08 95       	ret

00001970 <xTaskResumeAll>:
    1970:	cf 92       	push	r12
    1972:	df 92       	push	r13
    1974:	ef 92       	push	r14
    1976:	ff 92       	push	r15
    1978:	0f 93       	push	r16
    197a:	1f 93       	push	r17
    197c:	cf 93       	push	r28
    197e:	df 93       	push	r29
    1980:	0f b6       	in	r0, 0x3f	; 63
    1982:	f8 94       	cli
    1984:	0f 92       	push	r0
    1986:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <uxSchedulerSuspended>
    198a:	81 50       	subi	r24, 0x01	; 1
    198c:	80 93 bc 03 	sts	0x03BC, r24	; 0x8003bc <uxSchedulerSuspended>
    1990:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <uxSchedulerSuspended>
    1994:	81 11       	cpse	r24, r1
    1996:	64 c0       	rjmp	.+200    	; 0x1a60 <xTaskResumeAll+0xf0>
    1998:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <uxCurrentNumberOfTasks>
    199c:	81 11       	cpse	r24, r1
    199e:	32 c0       	rjmp	.+100    	; 0x1a04 <xTaskResumeAll+0x94>
    19a0:	62 c0       	rjmp	.+196    	; 0x1a66 <xTaskResumeAll+0xf6>
    19a2:	d7 01       	movw	r26, r14
    19a4:	15 96       	adiw	r26, 0x05	; 5
    19a6:	ed 91       	ld	r30, X+
    19a8:	fc 91       	ld	r31, X
    19aa:	16 97       	sbiw	r26, 0x06	; 6
    19ac:	c6 81       	ldd	r28, Z+6	; 0x06
    19ae:	d7 81       	ldd	r29, Z+7	; 0x07
    19b0:	ce 01       	movw	r24, r28
    19b2:	0c 96       	adiw	r24, 0x0c	; 12
    19b4:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
    19b8:	8e 01       	movw	r16, r28
    19ba:	0e 5f       	subi	r16, 0xFE	; 254
    19bc:	1f 4f       	sbci	r17, 0xFF	; 255
    19be:	c8 01       	movw	r24, r16
    19c0:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
    19c4:	8e 89       	ldd	r24, Y+22	; 0x16
    19c6:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <uxTopReadyPriority>
    19ca:	98 17       	cp	r25, r24
    19cc:	10 f4       	brcc	.+4      	; 0x19d2 <xTaskResumeAll+0x62>
    19ce:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <uxTopReadyPriority>
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	9c 01       	movw	r18, r24
    19d6:	22 0f       	add	r18, r18
    19d8:	33 1f       	adc	r19, r19
    19da:	22 0f       	add	r18, r18
    19dc:	33 1f       	adc	r19, r19
    19de:	22 0f       	add	r18, r18
    19e0:	33 1f       	adc	r19, r19
    19e2:	82 0f       	add	r24, r18
    19e4:	93 1f       	adc	r25, r19
    19e6:	b8 01       	movw	r22, r16
    19e8:	84 51       	subi	r24, 0x14	; 20
    19ea:	9c 4f       	sbci	r25, 0xFC	; 252
    19ec:	0e 94 7e 05 	call	0xafc	; 0xafc <vListInsertEnd>
    19f0:	e0 91 07 04 	lds	r30, 0x0407	; 0x800407 <pxCurrentTCB>
    19f4:	f0 91 08 04 	lds	r31, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    19f8:	9e 89       	ldd	r25, Y+22	; 0x16
    19fa:	86 89       	ldd	r24, Z+22	; 0x16
    19fc:	98 17       	cp	r25, r24
    19fe:	58 f0       	brcs	.+22     	; 0x1a16 <xTaskResumeAll+0xa6>
    1a00:	dc 2c       	mov	r13, r12
    1a02:	09 c0       	rjmp	.+18     	; 0x1a16 <xTaskResumeAll+0xa6>
    1a04:	d1 2c       	mov	r13, r1
    1a06:	0f 2e       	mov	r0, r31
    1a08:	fd ec       	ldi	r31, 0xCD	; 205
    1a0a:	ef 2e       	mov	r14, r31
    1a0c:	f3 e0       	ldi	r31, 0x03	; 3
    1a0e:	ff 2e       	mov	r15, r31
    1a10:	f0 2d       	mov	r31, r0
    1a12:	cc 24       	eor	r12, r12
    1a14:	c3 94       	inc	r12
    1a16:	f7 01       	movw	r30, r14
    1a18:	80 81       	ld	r24, Z
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	c2 cf       	rjmp	.-124    	; 0x19a2 <xTaskResumeAll+0x32>
    1a1e:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <uxMissedTicks>
    1a22:	88 23       	and	r24, r24
    1a24:	81 f0       	breq	.+32     	; 0x1a46 <xTaskResumeAll+0xd6>
    1a26:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <uxMissedTicks>
    1a2a:	88 23       	and	r24, r24
    1a2c:	99 f0       	breq	.+38     	; 0x1a54 <xTaskResumeAll+0xe4>
    1a2e:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <vTaskIncrementTick>
    1a32:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <uxMissedTicks>
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	80 93 bb 03 	sts	0x03BB, r24	; 0x8003bb <uxMissedTicks>
    1a3c:	80 91 bb 03 	lds	r24, 0x03BB	; 0x8003bb <uxMissedTicks>
    1a40:	81 11       	cpse	r24, r1
    1a42:	f5 cf       	rjmp	.-22     	; 0x1a2e <xTaskResumeAll+0xbe>
    1a44:	07 c0       	rjmp	.+14     	; 0x1a54 <xTaskResumeAll+0xe4>
    1a46:	f1 e0       	ldi	r31, 0x01	; 1
    1a48:	df 16       	cp	r13, r31
    1a4a:	21 f0       	breq	.+8      	; 0x1a54 <xTaskResumeAll+0xe4>
    1a4c:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <xMissedYield>
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	41 f4       	brne	.+16     	; 0x1a64 <xTaskResumeAll+0xf4>
    1a54:	10 92 ba 03 	sts	0x03BA, r1	; 0x8003ba <xMissedYield>
    1a58:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vPortYield>
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	03 c0       	rjmp	.+6      	; 0x1a66 <xTaskResumeAll+0xf6>
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    1a62:	01 c0       	rjmp	.+2      	; 0x1a66 <xTaskResumeAll+0xf6>
    1a64:	80 e0       	ldi	r24, 0x00	; 0
    1a66:	0f 90       	pop	r0
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	df 91       	pop	r29
    1a6c:	cf 91       	pop	r28
    1a6e:	1f 91       	pop	r17
    1a70:	0f 91       	pop	r16
    1a72:	ff 90       	pop	r15
    1a74:	ef 90       	pop	r14
    1a76:	df 90       	pop	r13
    1a78:	cf 90       	pop	r12
    1a7a:	08 95       	ret

00001a7c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1a7c:	cf 93       	push	r28
    1a7e:	df 93       	push	r29
    1a80:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1a82:	89 2b       	or	r24, r25
    1a84:	b1 f0       	breq	.+44     	; 0x1ab2 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1a86:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1a8a:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <xTickCount>
    1a8e:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <xTickCount+0x1>
    1a92:	c8 0f       	add	r28, r24
    1a94:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1a96:	80 91 07 04 	lds	r24, 0x0407	; 0x800407 <pxCurrentTCB>
    1a9a:	90 91 08 04 	lds	r25, 0x0408	; 0x800408 <pxCurrentTCB+0x1>
    1a9e:	02 96       	adiw	r24, 0x02	; 2
    1aa0:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	0e 94 8b 0a 	call	0x1516	; 0x1516 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1aaa:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1aae:	81 11       	cpse	r24, r1
    1ab0:	02 c0       	rjmp	.+4      	; 0x1ab6 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1ab2:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vPortYield>
		}
	}
    1ab6:	df 91       	pop	r29
    1ab8:	cf 91       	pop	r28
    1aba:	08 95       	ret

00001abc <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1abc:	04 ec       	ldi	r16, 0xC4	; 196
    1abe:	13 e0       	ldi	r17, 0x03	; 3
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1ac0:	80 91 c3 03 	lds	r24, 0x03C3	; 0x8003c3 <uxTasksDeleted>
    1ac4:	88 23       	and	r24, r24
    1ac6:	e1 f3       	breq	.-8      	; 0x1ac0 <prvIdleTask+0x4>
		{
			vTaskSuspendAll();
    1ac8:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1acc:	d8 01       	movw	r26, r16
    1ace:	cc 91       	ld	r28, X
			xTaskResumeAll();
    1ad0:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1ad4:	cc 23       	and	r28, r28
    1ad6:	a1 f3       	breq	.-24     	; 0x1ac0 <prvIdleTask+0x4>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1ade:	d8 01       	movw	r26, r16
    1ae0:	15 96       	adiw	r26, 0x05	; 5
    1ae2:	ed 91       	ld	r30, X+
    1ae4:	fc 91       	ld	r31, X
    1ae6:	16 97       	sbiw	r26, 0x06	; 6
    1ae8:	c6 81       	ldd	r28, Z+6	; 0x06
    1aea:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1aec:	ce 01       	movw	r24, r28
    1aee:	02 96       	adiw	r24, 0x02	; 2
    1af0:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListRemove>
					--uxCurrentNumberOfTasks;
    1af4:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <uxCurrentNumberOfTasks>
    1af8:	81 50       	subi	r24, 0x01	; 1
    1afa:	80 93 c2 03 	sts	0x03C2, r24	; 0x8003c2 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1afe:	80 91 c3 03 	lds	r24, 0x03C3	; 0x8003c3 <uxTasksDeleted>
    1b02:	81 50       	subi	r24, 0x01	; 1
    1b04:	80 93 c3 03 	sts	0x03C3, r24	; 0x8003c3 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1b0c:	8f 89       	ldd	r24, Y+23	; 0x17
    1b0e:	98 8d       	ldd	r25, Y+24	; 0x18
    1b10:	0e 94 b0 03 	call	0x760	; 0x760 <vPortFree>
		vPortFree( pxTCB );
    1b14:	ce 01       	movw	r24, r28
    1b16:	0e 94 b0 03 	call	0x760	; 0x760 <vPortFree>
    1b1a:	d2 cf       	rjmp	.-92     	; 0x1ac0 <prvIdleTask+0x4>

00001b1c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1b1c:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <uxSchedulerSuspended>
    1b20:	81 11       	cpse	r24, r1
    1b22:	13 c0       	rjmp	.+38     	; 0x1b4a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1b24:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <uxTopReadyPriority>
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	ee 0f       	add	r30, r30
    1b2e:	ff 1f       	adc	r31, r31
    1b30:	ee 0f       	add	r30, r30
    1b32:	ff 1f       	adc	r31, r31
    1b34:	ee 0f       	add	r30, r30
    1b36:	ff 1f       	adc	r31, r31
    1b38:	8e 0f       	add	r24, r30
    1b3a:	9f 1f       	adc	r25, r31
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	e4 51       	subi	r30, 0x14	; 20
    1b40:	fc 4f       	sbci	r31, 0xFC	; 252
    1b42:	80 81       	ld	r24, Z
    1b44:	88 23       	and	r24, r24
    1b46:	29 f0       	breq	.+10     	; 0x1b52 <vTaskSwitchContext+0x36>
    1b48:	1b c0       	rjmp	.+54     	; 0x1b80 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1b4a:	81 e0       	ldi	r24, 0x01	; 1
    1b4c:	80 93 ba 03 	sts	0x03BA, r24	; 0x8003ba <xMissedYield>
    1b50:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1b52:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <uxTopReadyPriority>
    1b56:	81 50       	subi	r24, 0x01	; 1
    1b58:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1b5c:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <uxTopReadyPriority>
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	fc 01       	movw	r30, r24
    1b64:	ee 0f       	add	r30, r30
    1b66:	ff 1f       	adc	r31, r31
    1b68:	ee 0f       	add	r30, r30
    1b6a:	ff 1f       	adc	r31, r31
    1b6c:	ee 0f       	add	r30, r30
    1b6e:	ff 1f       	adc	r31, r31
    1b70:	8e 0f       	add	r24, r30
    1b72:	9f 1f       	adc	r25, r31
    1b74:	fc 01       	movw	r30, r24
    1b76:	e4 51       	subi	r30, 0x14	; 20
    1b78:	fc 4f       	sbci	r31, 0xFC	; 252
    1b7a:	80 81       	ld	r24, Z
    1b7c:	88 23       	and	r24, r24
    1b7e:	49 f3       	breq	.-46     	; 0x1b52 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1b80:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <uxTopReadyPriority>
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	9c 01       	movw	r18, r24
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	22 0f       	add	r18, r18
    1b8e:	33 1f       	adc	r19, r19
    1b90:	22 0f       	add	r18, r18
    1b92:	33 1f       	adc	r19, r19
    1b94:	28 0f       	add	r18, r24
    1b96:	39 1f       	adc	r19, r25
    1b98:	d9 01       	movw	r26, r18
    1b9a:	a4 51       	subi	r26, 0x14	; 20
    1b9c:	bc 4f       	sbci	r27, 0xFC	; 252
    1b9e:	11 96       	adiw	r26, 0x01	; 1
    1ba0:	ed 91       	ld	r30, X+
    1ba2:	fc 91       	ld	r31, X
    1ba4:	12 97       	sbiw	r26, 0x02	; 2
    1ba6:	02 80       	ldd	r0, Z+2	; 0x02
    1ba8:	f3 81       	ldd	r31, Z+3	; 0x03
    1baa:	e0 2d       	mov	r30, r0
    1bac:	12 96       	adiw	r26, 0x02	; 2
    1bae:	fc 93       	st	X, r31
    1bb0:	ee 93       	st	-X, r30
    1bb2:	11 97       	sbiw	r26, 0x01	; 1
    1bb4:	21 51       	subi	r18, 0x11	; 17
    1bb6:	3c 4f       	sbci	r19, 0xFC	; 252
    1bb8:	e2 17       	cp	r30, r18
    1bba:	f3 07       	cpc	r31, r19
    1bbc:	29 f4       	brne	.+10     	; 0x1bc8 <vTaskSwitchContext+0xac>
    1bbe:	22 81       	ldd	r18, Z+2	; 0x02
    1bc0:	33 81       	ldd	r19, Z+3	; 0x03
    1bc2:	fd 01       	movw	r30, r26
    1bc4:	32 83       	std	Z+2, r19	; 0x02
    1bc6:	21 83       	std	Z+1, r18	; 0x01
    1bc8:	fc 01       	movw	r30, r24
    1bca:	ee 0f       	add	r30, r30
    1bcc:	ff 1f       	adc	r31, r31
    1bce:	ee 0f       	add	r30, r30
    1bd0:	ff 1f       	adc	r31, r31
    1bd2:	ee 0f       	add	r30, r30
    1bd4:	ff 1f       	adc	r31, r31
    1bd6:	8e 0f       	add	r24, r30
    1bd8:	9f 1f       	adc	r25, r31
    1bda:	fc 01       	movw	r30, r24
    1bdc:	e4 51       	subi	r30, 0x14	; 20
    1bde:	fc 4f       	sbci	r31, 0xFC	; 252
    1be0:	01 80       	ldd	r0, Z+1	; 0x01
    1be2:	f2 81       	ldd	r31, Z+2	; 0x02
    1be4:	e0 2d       	mov	r30, r0
    1be6:	86 81       	ldd	r24, Z+6	; 0x06
    1be8:	97 81       	ldd	r25, Z+7	; 0x07
    1bea:	90 93 08 04 	sts	0x0408, r25	; 0x800408 <pxCurrentTCB+0x1>
    1bee:	80 93 07 04 	sts	0x0407, r24	; 0x800407 <pxCurrentTCB>
    1bf2:	08 95       	ret

00001bf4 <__divmodhi4>:
    1bf4:	97 fb       	bst	r25, 7
    1bf6:	07 2e       	mov	r0, r23
    1bf8:	16 f4       	brtc	.+4      	; 0x1bfe <__divmodhi4+0xa>
    1bfa:	00 94       	com	r0
    1bfc:	07 d0       	rcall	.+14     	; 0x1c0c <__divmodhi4_neg1>
    1bfe:	77 fd       	sbrc	r23, 7
    1c00:	09 d0       	rcall	.+18     	; 0x1c14 <__divmodhi4_neg2>
    1c02:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <__udivmodhi4>
    1c06:	07 fc       	sbrc	r0, 7
    1c08:	05 d0       	rcall	.+10     	; 0x1c14 <__divmodhi4_neg2>
    1c0a:	3e f4       	brtc	.+14     	; 0x1c1a <__divmodhi4_exit>

00001c0c <__divmodhi4_neg1>:
    1c0c:	90 95       	com	r25
    1c0e:	81 95       	neg	r24
    1c10:	9f 4f       	sbci	r25, 0xFF	; 255
    1c12:	08 95       	ret

00001c14 <__divmodhi4_neg2>:
    1c14:	70 95       	com	r23
    1c16:	61 95       	neg	r22
    1c18:	7f 4f       	sbci	r23, 0xFF	; 255

00001c1a <__divmodhi4_exit>:
    1c1a:	08 95       	ret

00001c1c <__udivmodsi4>:
    1c1c:	a1 e2       	ldi	r26, 0x21	; 33
    1c1e:	1a 2e       	mov	r1, r26
    1c20:	aa 1b       	sub	r26, r26
    1c22:	bb 1b       	sub	r27, r27
    1c24:	fd 01       	movw	r30, r26
    1c26:	0d c0       	rjmp	.+26     	; 0x1c42 <__udivmodsi4_ep>

00001c28 <__udivmodsi4_loop>:
    1c28:	aa 1f       	adc	r26, r26
    1c2a:	bb 1f       	adc	r27, r27
    1c2c:	ee 1f       	adc	r30, r30
    1c2e:	ff 1f       	adc	r31, r31
    1c30:	a2 17       	cp	r26, r18
    1c32:	b3 07       	cpc	r27, r19
    1c34:	e4 07       	cpc	r30, r20
    1c36:	f5 07       	cpc	r31, r21
    1c38:	20 f0       	brcs	.+8      	; 0x1c42 <__udivmodsi4_ep>
    1c3a:	a2 1b       	sub	r26, r18
    1c3c:	b3 0b       	sbc	r27, r19
    1c3e:	e4 0b       	sbc	r30, r20
    1c40:	f5 0b       	sbc	r31, r21

00001c42 <__udivmodsi4_ep>:
    1c42:	66 1f       	adc	r22, r22
    1c44:	77 1f       	adc	r23, r23
    1c46:	88 1f       	adc	r24, r24
    1c48:	99 1f       	adc	r25, r25
    1c4a:	1a 94       	dec	r1
    1c4c:	69 f7       	brne	.-38     	; 0x1c28 <__udivmodsi4_loop>
    1c4e:	60 95       	com	r22
    1c50:	70 95       	com	r23
    1c52:	80 95       	com	r24
    1c54:	90 95       	com	r25
    1c56:	9b 01       	movw	r18, r22
    1c58:	ac 01       	movw	r20, r24
    1c5a:	bd 01       	movw	r22, r26
    1c5c:	cf 01       	movw	r24, r30
    1c5e:	08 95       	ret

00001c60 <__tablejump2__>:
    1c60:	ee 0f       	add	r30, r30
    1c62:	ff 1f       	adc	r31, r31
    1c64:	05 90       	lpm	r0, Z+
    1c66:	f4 91       	lpm	r31, Z
    1c68:	e0 2d       	mov	r30, r0
    1c6a:	09 94       	ijmp

00001c6c <__muluhisi3>:
    1c6c:	0e 94 55 0e 	call	0x1caa	; 0x1caa <__umulhisi3>
    1c70:	a5 9f       	mul	r26, r21
    1c72:	90 0d       	add	r25, r0
    1c74:	b4 9f       	mul	r27, r20
    1c76:	90 0d       	add	r25, r0
    1c78:	a4 9f       	mul	r26, r20
    1c7a:	80 0d       	add	r24, r0
    1c7c:	91 1d       	adc	r25, r1
    1c7e:	11 24       	eor	r1, r1
    1c80:	08 95       	ret

00001c82 <__udivmodhi4>:
    1c82:	aa 1b       	sub	r26, r26
    1c84:	bb 1b       	sub	r27, r27
    1c86:	51 e1       	ldi	r21, 0x11	; 17
    1c88:	07 c0       	rjmp	.+14     	; 0x1c98 <__udivmodhi4_ep>

00001c8a <__udivmodhi4_loop>:
    1c8a:	aa 1f       	adc	r26, r26
    1c8c:	bb 1f       	adc	r27, r27
    1c8e:	a6 17       	cp	r26, r22
    1c90:	b7 07       	cpc	r27, r23
    1c92:	10 f0       	brcs	.+4      	; 0x1c98 <__udivmodhi4_ep>
    1c94:	a6 1b       	sub	r26, r22
    1c96:	b7 0b       	sbc	r27, r23

00001c98 <__udivmodhi4_ep>:
    1c98:	88 1f       	adc	r24, r24
    1c9a:	99 1f       	adc	r25, r25
    1c9c:	5a 95       	dec	r21
    1c9e:	a9 f7       	brne	.-22     	; 0x1c8a <__udivmodhi4_loop>
    1ca0:	80 95       	com	r24
    1ca2:	90 95       	com	r25
    1ca4:	bc 01       	movw	r22, r24
    1ca6:	cd 01       	movw	r24, r26
    1ca8:	08 95       	ret

00001caa <__umulhisi3>:
    1caa:	a2 9f       	mul	r26, r18
    1cac:	b0 01       	movw	r22, r0
    1cae:	b3 9f       	mul	r27, r19
    1cb0:	c0 01       	movw	r24, r0
    1cb2:	a3 9f       	mul	r26, r19
    1cb4:	70 0d       	add	r23, r0
    1cb6:	81 1d       	adc	r24, r1
    1cb8:	11 24       	eor	r1, r1
    1cba:	91 1d       	adc	r25, r1
    1cbc:	b2 9f       	mul	r27, r18
    1cbe:	70 0d       	add	r23, r0
    1cc0:	81 1d       	adc	r24, r1
    1cc2:	11 24       	eor	r1, r1
    1cc4:	91 1d       	adc	r25, r1
    1cc6:	08 95       	ret

00001cc8 <memset>:
    1cc8:	dc 01       	movw	r26, r24
    1cca:	01 c0       	rjmp	.+2      	; 0x1cce <memset+0x6>
    1ccc:	6d 93       	st	X+, r22
    1cce:	41 50       	subi	r20, 0x01	; 1
    1cd0:	50 40       	sbci	r21, 0x00	; 0
    1cd2:	e0 f7       	brcc	.-8      	; 0x1ccc <memset+0x4>
    1cd4:	08 95       	ret

00001cd6 <strncpy>:
    1cd6:	fb 01       	movw	r30, r22
    1cd8:	dc 01       	movw	r26, r24
    1cda:	41 50       	subi	r20, 0x01	; 1
    1cdc:	50 40       	sbci	r21, 0x00	; 0
    1cde:	48 f0       	brcs	.+18     	; 0x1cf2 <strncpy+0x1c>
    1ce0:	01 90       	ld	r0, Z+
    1ce2:	0d 92       	st	X+, r0
    1ce4:	00 20       	and	r0, r0
    1ce6:	c9 f7       	brne	.-14     	; 0x1cda <strncpy+0x4>
    1ce8:	01 c0       	rjmp	.+2      	; 0x1cec <strncpy+0x16>
    1cea:	1d 92       	st	X+, r1
    1cec:	41 50       	subi	r20, 0x01	; 1
    1cee:	50 40       	sbci	r21, 0x00	; 0
    1cf0:	e0 f7       	brcc	.-8      	; 0x1cea <strncpy+0x14>
    1cf2:	08 95       	ret

00001cf4 <__itoa_ncheck>:
    1cf4:	bb 27       	eor	r27, r27
    1cf6:	4a 30       	cpi	r20, 0x0A	; 10
    1cf8:	31 f4       	brne	.+12     	; 0x1d06 <__itoa_ncheck+0x12>
    1cfa:	99 23       	and	r25, r25
    1cfc:	22 f4       	brpl	.+8      	; 0x1d06 <__itoa_ncheck+0x12>
    1cfe:	bd e2       	ldi	r27, 0x2D	; 45
    1d00:	90 95       	com	r25
    1d02:	81 95       	neg	r24
    1d04:	9f 4f       	sbci	r25, 0xFF	; 255
    1d06:	0c 94 86 0e 	jmp	0x1d0c	; 0x1d0c <__utoa_common>

00001d0a <__utoa_ncheck>:
    1d0a:	bb 27       	eor	r27, r27

00001d0c <__utoa_common>:
    1d0c:	fb 01       	movw	r30, r22
    1d0e:	55 27       	eor	r21, r21
    1d10:	aa 27       	eor	r26, r26
    1d12:	88 0f       	add	r24, r24
    1d14:	99 1f       	adc	r25, r25
    1d16:	aa 1f       	adc	r26, r26
    1d18:	a4 17       	cp	r26, r20
    1d1a:	10 f0       	brcs	.+4      	; 0x1d20 <__utoa_common+0x14>
    1d1c:	a4 1b       	sub	r26, r20
    1d1e:	83 95       	inc	r24
    1d20:	50 51       	subi	r21, 0x10	; 16
    1d22:	b9 f7       	brne	.-18     	; 0x1d12 <__utoa_common+0x6>
    1d24:	a0 5d       	subi	r26, 0xD0	; 208
    1d26:	aa 33       	cpi	r26, 0x3A	; 58
    1d28:	08 f0       	brcs	.+2      	; 0x1d2c <__utoa_common+0x20>
    1d2a:	a9 5d       	subi	r26, 0xD9	; 217
    1d2c:	a1 93       	st	Z+, r26
    1d2e:	00 97       	sbiw	r24, 0x00	; 0
    1d30:	79 f7       	brne	.-34     	; 0x1d10 <__utoa_common+0x4>
    1d32:	b1 11       	cpse	r27, r1
    1d34:	b1 93       	st	Z+, r27
    1d36:	11 92       	st	Z+, r1
    1d38:	cb 01       	movw	r24, r22
    1d3a:	0c 94 9f 0e 	jmp	0x1d3e	; 0x1d3e <strrev>

00001d3e <strrev>:
    1d3e:	dc 01       	movw	r26, r24
    1d40:	fc 01       	movw	r30, r24
    1d42:	67 2f       	mov	r22, r23
    1d44:	71 91       	ld	r23, Z+
    1d46:	77 23       	and	r23, r23
    1d48:	e1 f7       	brne	.-8      	; 0x1d42 <strrev+0x4>
    1d4a:	32 97       	sbiw	r30, 0x02	; 2
    1d4c:	04 c0       	rjmp	.+8      	; 0x1d56 <strrev+0x18>
    1d4e:	7c 91       	ld	r23, X
    1d50:	6d 93       	st	X+, r22
    1d52:	70 83       	st	Z, r23
    1d54:	62 91       	ld	r22, -Z
    1d56:	ae 17       	cp	r26, r30
    1d58:	bf 07       	cpc	r27, r31
    1d5a:	c8 f3       	brcs	.-14     	; 0x1d4e <strrev+0x10>
    1d5c:	08 95       	ret

00001d5e <_exit>:
    1d5e:	f8 94       	cli

00001d60 <__stop_program>:
    1d60:	ff cf       	rjmp	.-2      	; 0x1d60 <__stop_program>
